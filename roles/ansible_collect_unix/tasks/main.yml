---
- name: Error handling control block
  block:
    - name: Creating directory on target
      ansible.builtin.file:
        path: "{{ temp_dir }}"
        state: directory
        mode: "0700"
      register: conn_status
      ignore_errors: true
      ignore_unreachable: true
  always:
    - name: Generate RC
      ansible.builtin.include_role:
        name: returncode
      vars:
        rc_variables: "{{ udc_return_codes['compute_conn'] }}"
      when:
        - conn_status.unreachable is defined
        - conn_status.unreachable | bool

    - name: Fail UDC run for the host
      ansible.builtin.fail:
        msg: "{{ udc_return_codes['compute_conn']['rc_message'] }}"
      when:
        - conn_status.unreachable is defined
        - conn_status.unreachable | bool

- name: Creating destination directory on Control Node
  ansible.builtin.file:
    path: "{{ control_temp_dir }}"
    state: directory
    mode: "0700"
  delegate_to: localhost

- name: Collect required facts
  ansible.builtin.setup:
    gather_subset:
      - '!all'
      - '!min'
      - 'distribution'
      - 'python'
      - 'env'
      - 'architecture'
    gather_timeout: 120
  no_log: true

- name: Data collection prepare block
  delegate_to: localhost
  block:
    - name: Set udc_os_version
      ansible.builtin.set_fact:
        udc_os_version: >-
          {% if namebase in "['canonical_os_ubuntu', 'ibm_os_aix']" %}{{ ansible_facts['distribution_version'] | replace('.', '') }}{%
          else %}{{ ansible_facts['distribution_major_version'] }}{% endif %}
      when: namebase not in udc_rules_server_skip_osversion

    - name: Local policies from forks
      when: not (use_bps_rules_server | default(False) | bool)
      block:
        - name: Define acceptable policy patterns
          ansible.builtin.set_fact:
            policy_patterns:
              - '{{ namebase }}.local.{{ account_code }}.{{ udc_local_pol_filter | default("*") }}.pol'
              - '{{ inventory_hostname }}.{{ namebase }}.local.{{ udc_local_pol_filter | default("*") }}.pol'

        - name: Add the udc_os_version dependent policy matcher when running an OS collector
          ansible.builtin.set_fact:
            policy_patterns: >
              {{ policy_patterns + [namebase + '.local.security.' + udc_os_version + '.'
              + udc_local_pol_filter | default("*") + '.pol'] }}
          when: namebase.split("_")[1] == "os"

        - name: Add the udc_os_version independent security policy matcher when running a non-OS collector
          ansible.builtin.set_fact:
            policy_patterns: >
              {{ policy_patterns + [namebase + '.local.security.' + udc_local_pol_filter | default("*") + '.pol'] }}
          when: namebase.split("_")[1] != "os"

        - name: Find the policy files
          ansible.builtin.find:
            paths: '{{ role_path }}/files'
            patterns: "{{ policy_patterns }}"
            use_regex: true
          register: policy_files

    - name: Find the variable templates
      ansible.builtin.find:
        paths: '{{ role_path }}/templates'
        patterns: '{{ namebase }}.global.j2,{{ namebase }}.local.{{ udc_local_code_filter | default("*") }}.j2'
        use_regex: true
      register: vars_list

    - name: Generate the check_list files from templates
      ansible.builtin.template:
        src: "{{ item }}"
        dest: "{{ control_temp_dir }}/{{ item[:-3] | basename }}.yml"
        force: true
        mode: "0600"
      loop: "{{ vars_list.files | map(attribute='path') | list }}"

    - name: Constructing settings_local block
      when: vars_list.matched != 1
      block:
        - name: Create settings_local as an empty list
          ansible.builtin.set_fact:
            settings_local: []

        - name: Find the local variable files
          ansible.builtin.find:
            paths: '{{ control_temp_dir }}'
            patterns: '*.local.*.yml'
          register: local_settings_files_list

        - name: Error handling control block - Only run if local files found
          when: local_settings_files_list.files[0] is defined
          block:
            - name: Parse dicts from local variable files
              ansible.builtin.debug:
                msg: "{{ lookup('file', item) | from_yaml }}"
              loop: "{{ local_settings_files_list.files | map(attribute='path') | list }}"
              register: local_checks

            - name: Concatenate dicts to settings_local
              ansible.builtin.set_fact:
                settings_local: "{% if item | type_debug == 'list' %}{{ settings_local + item }}{% else %}{{ settings_local }}{% endif %}"
              loop: "{{ local_checks['results'] | map(attribute='msg') | list }}"
          rescue:
            - name: Generate RC
              ansible.builtin.include_role:
                name: returncode
              vars:
                rc_variables: "{{ udc_return_codes['local_template_issue'] }}"

            - name: Fail UDC run for the host
              ansible.builtin.fail:
                msg: "{{ udc_return_codes['local_template_issue']['rc_message'] }}"

    - name: Load global checks to run
      ansible.builtin.include_vars:
        file: "{{ control_temp_dir }}/{{ namebase }}.global.yml"
      no_log: true

    - name: Initialize settings_global and settings_local
      ansible.builtin.set_fact:
        settings: >-
          {% if settings_global | type_debug != 'NoneType' and settings_local is defined and
          settings_local | type_debug != 'NoneType' %}{{ settings_global + settings_local }}{%
          elif settings_global | type_debug == 'NoneType' and settings_local is defined and settings_local | type_debug != 'NoneType' %}{{ settings_local }}{%
          elif settings_global | type_debug != 'NoneType' and settings_local is defined and settings_local | type_debug == 'NoneType' %}{{ settings_global }}{%
          else %}{{ settings_global }}{% endif %}

- name: Generate the outputfile from template
  ansible.builtin.template:
    src: "{{ playbook_dir }}/templates/outbase.j2"
    dest: "{{ temp_dir }}/{{ out_file }}"
    mode: "0600"
    force: true

- name: Initialize logfile
  ansible.builtin.copy:
    content: "{{ '%Y-%m-%d %H:%M:%S' | strftime }} - DATA COLLECTION ON {{ satdevicename | default(inventory_hostname) | upper }} STARTED"
    dest: "{{ temp_dir }}/{{ log_file }}"
    mode: "0600"
    force: true

- name: Block for gathering data
  environment:
    PATH: "/usr/sbin:/sbin:{{ ansible_env.PATH }}"
    CATALINA_HOME: "{{ udc_catalina_home | default('') }}"
    CATALINA_BASE: "{{ udc_catalina_base | default('') }}"
  block:
    - name: Initialize exec_rc
      ansible.builtin.set_fact:
        exec_rc: 0
        error_on_exec: false
        fatal_on_exec: false

    - name: Gather data
      ansible.builtin.include_tasks: tasks/shell.yml
      loop: "{{ settings }}"
      loop_control:
        loop_var: commands

- name: Data collection finished block
  block:
    - name: Finalize logfile
      ansible.builtin.lineinfile:
        path: "{{ temp_dir }}/{{ log_file }}"
        line: "{{ item }}"
      loop:
        - "{{ '%Y-%m-%d %H:%M:%S' | strftime }} - DATA COLLECTION ON {{ satdevicename | default(inventory_hostname) | upper }} FINISHED \
           {% if error_on_exec is defined and error_on_exec | bool %}WITH ERRORS ({{ exec_rc }}){% else %}SUCCESSFULLY ({{ exec_rc }}){% endif %}"
        - "{{ '%a %b %d %H:%M:%S %Y' | strftime }}: Data collection status: {% if exec_rc != '3' and error_on_exec is defined and error_on_exec | bool %}\
           Failed{% else %}OK{% endif %}"

    - name: Set udc_collection_result variable
      ansible.builtin.set_fact:
        udc_collection_result: |-
          DATA COLLECTION ON {{ satdevicename | default(inventory_hostname) | upper }} FINISHED {% if error_on_exec is defined and error_on_exec | bool %}\
          WITH ERRORS ({{ exec_rc }}){% else %}SUCCESSFULLY ({{ exec_rc }}){% endif %}.
          Data collection status: {% if exec_rc != '3' and error_on_exec is defined and error_on_exec | bool %}Failed{% else %}OK{% endif %}

    - name: Copy policy files to destination on the Control Node
      ansible.builtin.copy:
        src: "{{ item }}"
        dest: "{{ control_temp_dir }}/{{ item | basename }}"
        mode: "0600"
      delegate_to: localhost
      loop: "{{ policy_files.files | map(attribute='path') | list }}"
      when: policy_files.files[0] is defined

    - name: Register the files to be fetched
      ansible.builtin.find:
        paths: '{{ temp_dir }}'
      register: bundle_elements

    - name: Fetch files from Endpoint
      ansible.builtin.fetch:
        src: "{{ temp_dir }}/{{ item | basename }}"
        dest: "{{ control_temp_dir }}/{{ item | basename }}"
        flat: true
      loop: "{{ bundle_elements.files | map(attribute='path') | list }}"

    - name: Compress files into Bundle
      community.general.archive:
        path:
          - "{{ control_temp_dir }}/*"
        exclude_path:
          - "{{ control_temp_dir }}/*.yml"
          - "{{ control_temp_dir }}/*.ps1"
        dest: "{{ control_temp_dir }}/../{{ bundle_file }}"
        mode: "0600"
        format: zip
        remove: true
      delegate_to: localhost
  always:
    - name: Delete created directory from the Endpoint
      ansible.builtin.file:
        path: "{{ temp_dir }}"
        state: absent
    - name: Delete created directory from the Control Node
      ansible.builtin.file:
        path: "{{ control_temp_dir }}"
        state: absent
      delegate_to: localhost
