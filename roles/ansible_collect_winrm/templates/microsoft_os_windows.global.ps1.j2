<# Detailed Instructions - https://github.kyndryl.net/Kyndryl-CISO/CAR-Data-Gathering/tree/master/Windows-Server-Health-Check-Local

{#udc_platform	= "Microsoft Windows Server" #}
{#available_for = "UDC" #}
{#udc_status	= "production" #}
{#udc_endpoint	= "windows" #}
{#responsible_sme = "TBD" #}
{#responsible_dev = "brunodj@kyndryl.com" #}
{#expected_release_date = "Released" #}
{#tpchcversion	= "2.11.0" #}
{#buildversion	= "2.11.0.20250402" #}
{#satteam	= "Compute" #}
{#hwswdomain	= "Compute" #}

#>

# ==============================================================================================================================
# Name:         microsoft_os_windows.global.ps1.j2
#
#               Windows Server Health Check script generating data for SAT
#
# Author:       Gica Livada, gica.livada@kyndryl.com, Kyndryl Inc.
#               Mircea Gaitan, mircea.gaitan@kyndryl.com, Kyndryl Inc.
#
#
# Change log:     20230309    Initial code
#                 20230511    Fixed ports open check bug https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1039394
#                 20230605    Fixed ports open check bug https://github.kyndryl.net/Continuous-Engineering/ansible_project_udc/issues/163
#                 20230608    Added LogonAccount - account used to start services in Windows_Services segment
#                 20230620    Fixed CachedLogonsCount segment https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1114839
#                 20230626    Fixed Diffie-Hellman default for Windows version 2016 and later https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1114918
#                 20230703    Fixed LocalAccountTokenFilterPolicy to be ignored if Standalone server https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1135777
#                 20230725    Removed username from Windows_User_Profiles segment. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1185591
#                 20230811    Fixed RSA registry key for Windows 2012. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1213216
#                 20230831    Using get-logproperites for Windows_EventLogs_Policy segment. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1246516
#                 20230925    Fix bug in Windows_time segment. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1301425
#                 20230929    Fix code in Windows_PKCS segment. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1262321
#                 20231116    Fix code in Windows_Defender segment. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1389392
#                 20231121    Remove code for IIS (IIS is treated as separate device). https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1393382
#                 20231121    Added code to include a certificate from root store in allcertificates segment. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1396285
#                 20231121    Fixed pagefile data in systeminfo segment when the server has set multiple pagefiles. https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1397853
#                 20231212    Fixed bug (remove -computername paramenter in ) in Windows_DiskInfo segment INCEU17020430 https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1427519
#                 20231213    Removed -computer or -computername parameter from Get-Software function and profile https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1427519
#                 20231213    Added sort-object in Windows_Programs segment
#                 20240109    Multiple updates to prepare TechSpecs code integration
#                 20240115    TechSpecs code integration completed
#                 20240116    Fix error in Windows_Patches when no patch is installed https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1551040
#                 20240125    New segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240202    Fix error https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1554670
#                 20240202    Added OS based defaults in SSL segment https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1567014
#                 20240208    Fix bug in Eventlogs_policy when maxfilesize is bigger than 2Gb https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1586333
#                 20240208    Optimized code for Eventlogs_policy when maxfilesize is bigger than 2Gb https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1586333
#                 20240214    New segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240215    Reorder certificates in allcertificates segment (first one is from root store)
#                 20240216    Yet new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240220    Another set of segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240222    Bug in windows time code (use case standalone servers/workstations) https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1605060
#                 20240223    Bug in windows time code https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1606932
#                 20240226    2 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240228    Fix typo from 2 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240229    4 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240229    6 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240301    Bug in Windows patches https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1610984
#                 20240304    Fix bug in Windows patches https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1610984
#                             - add DNS client configuration https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1608826
#                             - remove short lived certificates https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1611187
#                 20240304    21 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240307    32 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240312    30 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240314    94 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240315    fix 2 typos https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240325    New segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240326    2 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240328    2 new segments for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240415    1 new segment for TechSpecs https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1562659
#                 20240510    Create cacf_cfg when running standalone https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1707773
#                 20240605    Update get-useregkey function https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1762224
#                 20240617    Use provided values for tpchcversion and buildversion https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1779442
#                 20240708    Bug fix https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1818412
#                 20240715    Bug fix https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1828902
#                 20240717    Update pagefile metrics - size,usage,peakusage,tempusage - with sum if pagefile configured on multiple disks) https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1824573
#                 20240726    Bug fix https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1848075 - find.exe replaced with native PowerShell
#                 20240820    Added country code in SystemInfo https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1859581
#                 20240820    Fixed Windows_audipol segment in case non-English OS language https://dev.azure.com/Kyndryl/SAT/_workitems/edit/18802671
#                 20240821    Fixed bug in Fine-Grained Policy segment https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1884663
#                 20240821    Add info in Windows_Services segment for Triggered Start https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1859631
#                 20240903    Fixed bug in join-object function (allow empty objects as parameters) https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1896267
#                 20240910    Fixed bug in Windows_SMB_Server segment (affecting W2K8) https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1909335
#                 20241022    Removed "R2" from 2012 definition in sstable from Windows_SSL_TLS_State segment https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1971879
#                 20241210    Fixed bug in Windows_PKCS segment https://dev.azure.com/Kyndryl/SAT/_workitems/edit/2015589
#                 20241210    Add new segment Windows_VolumeInfo https://dev.azure.com/Kyndryl/Best%20Practice%20Service/_workitems/edit/2028280
#                 20250106    Updated segment "Windows_Lcl_Users" with all local users and included password never expired attribute https://dev.azure.com/Kyndryl/SAT/_workitems/edit/1649443
#                 20250106    Added missing variable for $RSA in Windows_PKCS segment https://dev.azure.com/Kyndryl/SAT/_workitems/edit/2015589
#                 20250113    Adding required registry keys for new policies on Windows Server 2022 https://dev.azure.com/Kyndryl/SAT/_workitems/edit/2066401
#                 20250116    Removed line 3691 (duplicate registry query) https://dev.azure.com/Kyndryl/SAT/_workitems/edit/2064573
#                 20250402    Updated segment "Windows_Lcl_Users" to skip collecting Domain users' data in Domain controllers and corrected segment name & numbers https://dev.azure.com/Kyndryl/SAT/_workitems/edit/2151404/ 
#
#
# How to use:     - Copy script to a folder e.g. C:\Temp
#                 - Open PowerShell on 64bit as "Administrator" - recommended is PowerSehll version 5.1 or later
#                 - Do not use PowerShell 32bit as the script will fail!
#                 - Set ExecutionPolicy to allow running script Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
#                 - Execute script.
#                 - The parameters logpath, logf, ziplog, account, blueid, chipid, location, satteam and hwswdomain
#                   can be entered in command line, can be entered at prompt or left empty (use default values).
#                 - Collect log generated for the server as [SERVERNAME]-[DATE]-report and forward it to SME for analysis
#
# ==============================================================================================================================

Param (
    [String]$Device_Name,
    [String]$LogPath,
    [String]$LogF,
    [String]$ZipLog,
    [String]$account,
    [String]$blueid,
    [String]$chipid,
    [String]$location,
    [String]$satteam,
    [String]$hwswdomain,
    [String]$satmode,
    [String]$udcmode,
    [String]$tpchcversion,
    [String]$buildversion
)

Function MsgPrint([string]$ShowStep, [string]$textMsg) {
    if ( $SATmode ) {
        if ( $log_to_logfile ) {
            # Tue Apr 24 08:52:07 2018: log text
            $myDate = get-date -format "yyyyMMdd-HHmmss"
            ($myDate).ToString() + ": " + $textMsg | Out-File $logf -encoding UTF8 -append
        }
        else {
            Write-Output $textMsg
        }
    }
    else {
        switch ($ShowStep.ToLower()) {
            "info"		{Write-Information -MessageData "INFO:   " $(get-date -format "yyyyMMdd-HHmmss") $textMsg }
            "highlight"	{Write-Information -MessageData "INFO:   " $(get-date -format "yyyyMMdd-HHmmss") $textMsg -foreground yellow}
			"debug" 	{if ($debug) {Write-Information -MessageData "DEBUG:  " $(get-date -format "yyyyMMdd-HHmmss") $textMsg -foreground green}}
            "ok"		{Write-Information -MessageData "OK:     " $(get-date -format "yyyyMMdd-HHmmss") $textMsg }
            "error"		{Write-Information -MessageData "ERROR:  " $(get-date -format "yyyyMMdd-HHmmss") $textMsg -foreground red }
            "warning"	{Write-Information -MessageData "WARNING:" $(get-date -format "yyyyMMdd-HHmmss") $textMsg -foreground yellow }
            "filelist"	{Write-Information -MessageData "FILES:  " $(get-date -format "yyyyMMdd-HHmmss") $textMsg }
            default		{Write-Information -MessageData "DEFAULT:" $(get-date -format "yyyyMMdd-HHmmss") $textMsg }
        }
    }
	return
}

Function Get-Software {
    <#
    .SYNOPSIS
    Get the software installed as a custom object

    .DESCRIPTION
    The function is using information from registry

    .EXAMPLE
    Get-Software

    .NOTES
    Adapted from https://mcpmag.com/articles/2017/07/27/gathering-installed-software-using-powershell.aspx
    #>

#    [OutputType('System.Software.Inventory')]
    [Cmdletbinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True)]
        [String[]]$Computername=$env:COMPUTERNAME
    )
    Process {
# Removed remote option. The function will work only on local computer
#        ForEach ($Computer in $Computername){
#            If (Test-Connection -ComputerName  $Computer -Count  1 -Quiet) {
                $Paths  = @("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall","SOFTWARE\\Wow6432node\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
                ForEach ($Path in $Paths) {
                    Write-Verbose  "Checking Path: $Path"
                    # Create an instance of the Registry Object and open the HKLM base key
                    Try {
                    # use local version of command
#                       $reg=[microsoft.win32.registrykey]::OpenRemoteBaseKey('LocalMachine',$Computer,'Registry64')
                        $reg=[microsoft.win32.registrykey]::OpenBaseKey('LocalMachine','Registry64')
                    }
                    Catch {
                        Write-Error $_
                        Continue
                    }
                    # Drill down into the Uninstall key using the OpenSubKey Method
                    Try {
                        $regkey=$reg.OpenSubKey($Path)
                        # Retrieve an array of string that contain all the subkey names
                        $subkeys=$regkey.GetSubKeyNames()
                        # Open each Subkey and use GetValue Method to return the required  values for each
                        ForEach ($key in $subkeys){
                            Write-Verbose "Key: $Key"
                            $thisKey=$Path+"\\"+$key
                            Try {
                                $thisSubKey=$reg.OpenSubKey($thisKey)
                                # Prevent Objects with empty DisplayName
                                $DisplayName =  $thisSubKey.getValue("DisplayName")
                                If ($DisplayName  -AND $DisplayName  -notmatch '^Update  for|rollup|^Security Update|^Service Pack|^HotFix') {
                                    $Date = $thisSubKey.GetValue('InstallDate')
                                    If ($Date) {
                                        Try {
                                            $Date = [datetime]::ParseExact($Date, 'yyyyMMdd', $Null)
                                            }
                                        Catch{
                                            Write-Warning "$($Computer): $_ <$($Date)>"
                                            $Date = $Null
                                        }
                                    }
                                    # Create New Object with empty Properties
                                    $Publisher =  Try {
                                        $thisSubKey.GetValue('Publisher').Trim()
                                    }
                                    Catch {
                                        $thisSubKey.GetValue('Publisher')
                                    }
                                    $Version = Try {
                                        #Some weirdness with trailing [char]0 on some strings
                                        $thisSubKey.GetValue('DisplayVersion').TrimEnd(([char[]](32,0)))
                                    }
                                    Catch {
                                        $thisSubKey.GetValue('DisplayVersion')
                                    }
                                    $UninstallString =  Try {
                                        $thisSubKey.GetValue('UninstallString').Trim()
                                    }
                                    Catch {
                                        $thisSubKey.GetValue('UninstallString')
                                    }
                                    $InstallLocation =  Try {
                                        $thisSubKey.GetValue('InstallLocation').Trim()
                                    }
                                    Catch {
                                        $thisSubKey.GetValue('InstallLocation')
                                    }
                                    $InstallSource =  Try {
                                        $thisSubKey.GetValue('InstallSource').Trim()
                                    }
                                    Catch {
                                        $thisSubKey.GetValue('InstallSource')
                                    }
                                    $HelpLink = Try {
                                        $thisSubKey.GetValue('HelpLink').Trim()
                                    }
                                    Catch {
                                        $thisSubKey.GetValue('HelpLink')
                                    }
                                    $Object = [pscustomobject]@{
                                        MachineName = $Computer
                                        Publisher = $Publisher
                                        DisplayName = $DisplayName
                                        Version  = $Version
                                        InstallDate = $Date
                                        UninstallString = $UninstallString
                                        InstallLocation = $InstallLocation
                                        InstallSource  = $InstallSource
                                        HelpLink = $HelpLink
                                        EstimatedSizeMB = [decimal]([math]::Round(($thisSubKey.GetValue('EstimatedSize')*1024)/1MB,2))
                                    }
                                    $Object.pstypenames.insert(0,'System.Software.Inventory')
                                    Write-Output $Object
                                }
                            }
                            Catch{
                                Write-Warning "$Key : $_"
                            }
                        }
                    }
                    Catch{
                        Write-Warning "Other error"
                    }
                    $reg.Close()
                }
            }
#            Else{
#                Write-Error  "$($Computer): unable to reach remote system!"
#           }
#        }
#    }
}

function Get-IniFile {
    <#
    .SYNOPSIS
    Read an ini file.

    .DESCRIPTION
    Reads an ini file into a hash table of sections with keys and values.

    .PARAMETER filePath
    The path to the INI file.

    .PARAMETER anonymous
    The section name to use for the anonymous section (keys that come before any section declaration).

    .PARAMETER comments
    Enables saving of comments to a comment section in the resulting hash table.
    The comments for each section will be stored in a section that has the same name as the section of its origin, but has the comment suffix appended.
    Comments will be keyed with the comment key prefix and a sequence number for the comment. The sequence number is reset for every section.

    .PARAMETER commentsSectionsSuffix
    The suffix for comment sections. The default value is an underscore ('_').
    .PARAMETER commentsKeyPrefix
    The prefix for comment keys. The default value is 'Comment'.

    .EXAMPLE
    Get-IniFile /path/to/my/inifile.ini

    .NOTES
    The resulting hash table has the form [sectionName->sectionContent], where sectionName is a string and sectionContent is a hash table of the form [key->value] where both are strings.
    This function is largely copied from https://stackoverflow.com/a/43697842/1031534. An improved version has since been pulished at https://gist.github.com/beruic/1be71ae570646bca40734280ea357e3c.
    #>

    param(
        [parameter(Mandatory = $true)] [string] $filePath,
        [string] $anonymous = 'NoSection',
        [switch] $comments,
        [string] $commentsSectionsSuffix = '_',
        [string] $commentsKeyPrefix = 'Comment'
    )

    $ini = @{}
    switch -regex -file ($filePath) {
        "^\[(.+)\]$" {
            # Section
            $section = $matches[1]
            $ini[$section] = @{}
            $CommentCount = 0
            if ($comments) {
                $commentsSection = $section + $commentsSectionsSuffix
                $ini[$commentsSection] = @{}
            }
            continue
        }

        "^(;.*)$" {
            # Comment
            if ($comments) {
                if (!($section)) {
                    $section = $anonymous
                    $ini[$section] = @{}
                }
                $value = $matches[1]
                $CommentCount = $CommentCount + 1
                $name = $commentsKeyPrefix + $CommentCount
                $commentsSection = $section + $commentsSectionsSuffix
                $ini[$commentsSection][$name] = $value
            }
            continue
        }

        "^(.+?)\s*=\s*(.*)$" {
            # Key
            if (!($section)) {
                $section = $anonymous
                $ini[$section] = @{}
            }
            $name, $value = $matches[1..2]
            $ini[$section][$name] = $value
            continue
        }
    }

    return $ini
}

# Function Get-RegKey
function Get-RegKey ([string]$s) {
    <#
    .SYNOPSIS
    Return Registry key

    .DESCRIPTION
    This function is retrieving the registry key  specified

    .PARAMETER s
    s is a string representing either a path to registry, either a path plus a key in with case the elements are separated by ":"

    .EXAMPLE
    Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:restrictanonymous"
    Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa"

    .NOTES
    It works only if out file - $file_stream_output - is defined outside funnction
    #>
    $rtn = @()
    try {
        if ($s.IndexOf(":") -gt 0) {
            $key = $s.split(":")[0]
            $name = $s.split(":")[1]
            $cmd = "(Get-ItemProperty -ErrorAction SilentlyContinue -Path Registry::"""+$key+""")."""+$name+""""
        } else {
            $key = $s
            $name = ""
            $cmd = "Get-ItemProperty -ErrorAction SilentlyContinue -Path Registry::"""+$key+""""
        }
        $regkeycontent = Invoke-Expression $cmd
        if ($regkeycontent -eq $null) {
            $rtn += "registry key not found"
        } elseif ($regkeycontent.Length -eq 0) {
                $rtn += "registry key empty"
            }
        else {
            foreach ($line in $regkeycontent) { $rtn += $line }
        }
    }
    catch {
        MsgPrint "error" "key extract failed [ $($s) ]"
        $rtn += "key extract failed"
    }
    return $rtn
}

# Function Get-Segment_Regkey
Function Get-Segment_Regkey {
    <#
    .SYNOPSIS
    Create segment in out file

    .DESCRIPTION
    This function is using Function Get-RegKey to retrieve the registry key

    .PARAMETER Regkey
    Regkey is a string representing a path or a key from registry.

    .PARAMETER Segment_Name
    Segment_Name is a string

    .EXAMPLE
    get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:restrictanonymous" -segment_name "Windows_Reg_Lsa:restrictanonymous"

    .NOTES
    It works only if out file - $file_stream_output - is defined outside funnction
    #>
    param(
        [Parameter(Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [string]$RegKey,
        [Parameter(Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [string]$Segment_Name
    )
    $file_stream_output.WriteLine("#### <$segment_name>")
    $out = @()
    foreach ($line in (Get-RegKey $RegKey)) {
        $out += [PSCustomObject]@{
                  "MachineName" = $computer
                  "Key" = $RegKey
                  "KeyValue" = $line
                  }
    }
    $out | ConvertTo-csv -Delimiter ';' -NoTypeInformation | Foreach-Object {$file_stream_output.WriteLine($_)}
    $file_stream_output.WriteLine("#### </$segment_name>")
}

# Function Get-UsersRegKey
function Get-UsersRegKey ([string]$s) {
    <#
    .SYNOPSIS
    Enumerates RegKeys from HKU

    .DESCRIPTION
    This function is using Function Get-RegKey to retrieve the registry key

    .PARAMETER s
    s is a string in format : "HKEY_USERS\[USER SID]\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoInplaceSharing"
    [USER SID] will be replaced dynamically as it goes through the user list

    .PARAMETER Segment_Name
    Segment_Name is a string

    .EXAMPLE
    Get-UsersRegKey "HKEY_USERS\[USER SID]\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoInplaceSharing"

    .NOTES
    #>

    # Prepare key/name
    if ($s.IndexOf(":") -gt 0) {
        $key = $s.split(":")[0]
        $name = $s.split(":")[1]
    } else {
        $key = $s
        $name = ""
    }

    # Regex pattern for SIDs
    $PatternSID = 'S-1-5-21-\d+-\d+\-\d+\-\d+$'

    # Get ServerRole. 4 = BDC and 5 = PDC will be used to exclude local users
    $computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem
    $serverRole = $computerSystem.DomainRole

    # Get Username, SID, and location of ntuser.dat for all users
    try {
        if (($serverRole) -in (4,5)) {
        $ProfileList = Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*' | Where-Object {($_.PSChildName -match $PatternSID) } |
            Select  @{name="SID";expression={$_.PSChildName}},
                    @{name="UserHive";expression={"$($_.ProfileImagePath)\ntuser.dat"}},
                    @{name="Username";expression={$_.ProfileImagePath -replace '^(.*[\\\/])', ''}}
        }
        else {
        $ProfileList = Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*' | Where-Object {($_.PSChildName -match $PatternSID) } |
            Select  @{name="SID";expression={$_.PSChildName}},
                    @{name="UserHive";expression={"$($_.ProfileImagePath)\ntuser.dat"}},
                    @{name="Username";expression={$_.ProfileImagePath -replace '^(.*[\\\/])', ''}}
        }
    # Get all user SIDs found in HKEY_USERS (ntuder.dat files that are loaded)
    $LoadedHives = Get-ChildItem Registry::HKEY_USERS | ? {$_.PSChildname -match $PatternSID} | Select @{name="SID";expression={$_.PSChildName}}

    # Get all users that are not currently logged
    if (!($ProfileList)) {
        $UnloadedHives = @()
    }
    else {
        $UnloadedHives = Compare-Object $ProfileList.SID $LoadedHives.SID | Select @{name="SID";expression={$_.InputObject}}
    }
    }
    catch {
        Write-host "error: Profile users $($Error[0].tostring())"
    }
    $rtn = @()
    $regkeys = @()

    # Loop through each profile on the machine
    Foreach ($item in $ProfileList) {
        try {
            # Load User ntuser.dat if it's not already loaded
            if ($item.SID -in $UnloadedHives.SID) { reg load HKU\$($Item.SID) $($Item.UserHive) | Out-Null }
            # This is where you read user portion of the registry
            $itemkey = $key.replace("[USER SID]",$item.SID)
            # Ignore users where \Software\Microsoft\Windows\CurrentVersion\Policies does not exists
            $pathpol =  "Registry::HKEY_USERS\"+$item.SID+"\Software\Microsoft\Windows\CurrentVersion\Group Policy\"
            if (test-path -path $pathpol) {
                if ($name -ne "") {
                    $cmd = "(Get-ItemProperty -ErrorAction SilentlyContinue -Path Registry::"""+$itemkey+""")."""+$name+""""
                }
                else {
                        $cmd = "Get-ItemProperty -ErrorAction SilentlyContinue -Path Registry::"""+$itemkey+""""
                }
                $regkeycontent = Invoke-Expression $cmd
                if (($regkeycontent -eq $null) -or ($regkeycontent.Length -eq 0)) {
                     $tmp = "" | Select-Object @{N="User";E={$item.UserName}},@{N="SID";E={$item.SID}},@{N="Key";E={"registry key not found"}
                }
                     $regkeys += $tmp }
                else {
                     foreach ($line in $regkeycontent) {
                         $tmp = "" | Select-Object @{N="User";E={$item.UserName}},@{N="SID";E={$item.SID}},@{N="Key";E={$line}} ; $regkeys += $tmp
                     }
                }
            }
            # Unload ntuser.dat
            if ($item.SID -in $UnloadedHives.SID) {
                ### Garbage collection and closing of ntuser.dat ###
                [gc]::Collect()
                reg unload HKU\$($Item.SID) | Out-Null
            }
        }
        catch {
            Write-host "error: Profile users key extract failed $($Error[0].tostring())"
            $tmp = "" | Select-Object @{N="User";E={$item.UserName}},@{N="SID";E={$item.SID}},@{N="Key";E={"key extract failed"}}
            $regkeys += $tmp
        }
    }
    $rtn += $regkeys
    return $rtn
}


# Function Get-Segment_UsersRegkey
Function Get-Segment_UsersRegkey {
    <#
    .SYNOPSIS
    Create segment in out file for user profile - registry

    .DESCRIPTION
    This function is using Function Get-UsersRegKey to retrieve the registry key

    .PARAMETER Regkey
    Regkey is a string in format : "HKEY_USERS\[USER SID]\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoInplaceSharing"
    [USER SID] will be replaced dynamically in function Get-UsersRegKey

    .PARAMETER Segment_Name
    Segment_Name is a string

    .EXAMPLE
    get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoInplaceSharing" -segment_name "Windows_Reg_User_Explorer:NoInplaceSharing"

    .NOTES
    It works only if out file - $file_stream_output - is defined outside funnction
    #>
    param(
        [Parameter(Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [string]$RegKey,
        [Parameter(Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [string]$Segment_Name
    )
    $file_stream_output.WriteLine("#### <$segment_name>")
    $out = Get-UsersRegKey $RegKey | Select-object @{n="MachineName";e={$Computer}}, @{n="KeyName";e={$RegKey}},User,SID,Key
    $out | ConvertTo-csv -Delimiter ';' -NoTypeInformation | Foreach-Object {$file_stream_output.WriteLine($_)}
    $file_stream_output.WriteLine("#### </$segment_name>")
}

function Join-Object
{
    <#
    .SYNOPSIS
        Join data from two sets of objects based on a common value

    .DESCRIPTION
        Join data from two sets of objects based on a common value

        For more details, see the accompanying blog post:
            http://ramblingcookiemonster.github.io/Join-Object/

        For even more details,  see the original code and discussions that this borrows from:
            Dave Wyatt's Join-Object - http://powershell.org/wp/forums/topic/merging-very-large-collections
            Lucio Silveira's Join-Object - http://blogs.msdn.com/b/powershell/archive/2012/07/13/join-object.aspx

    .PARAMETER Left
        'Left' collection of objects to join.  You can use the pipeline for Left.

        The objects in this collection should be consistent.
        We look at the properties on the first object for a baseline.

    .PARAMETER Right
        'Right' collection of objects to join.

        The objects in this collection should be consistent.
        We look at the properties on the first object for a baseline.

    .PARAMETER LeftJoinProperty
        Property on Left collection objects that we match up with RightJoinProperty on the Right collection

    .PARAMETER RightJoinProperty
        Property on Right collection objects that we match up with LeftJoinProperty on the Left collection

    .PARAMETER LeftProperties
        One or more properties to keep from Left.  Default is to keep all Left properties (*).

        Each property can:
            - Be a plain property name like "Name"
            - Contain wildcards like "*"
            - Be a hashtable like @{Name="Product Name";Expression={$_.Name}}.
                 Name is the output property name
                 Expression is the property value ($_ as the current object)

                 Alternatively, use the Suffix or Prefix parameter to avoid collisions
                 Each property using this hashtable syntax will be excluded from suffixes and prefixes

    .PARAMETER RightProperties
        One or more properties to keep from Right.  Default is to keep all Right properties (*).

        Each property can:
            - Be a plain property name like "Name"
            - Contain wildcards like "*"
            - Be a hashtable like @{Name="Product Name";Expression={$_.Name}}.
                 Name is the output property name
                 Expression is the property value ($_ as the current object)

                 Alternatively, use the Suffix or Prefix parameter to avoid collisions
                 Each property using this hashtable syntax will be excluded from suffixes and prefixes

    .PARAMETER Prefix
        If specified, prepend Right object property names with this prefix to avoid collisions

        Example:
            Property Name                   = 'Name'
            Suffix                          = 'j_'
            Resulting Joined Property Name  = 'j_Name'

    .PARAMETER Suffix
        If specified, append Right object property names with this suffix to avoid collisions

        Example:
            Property Name                   = 'Name'
            Suffix                          = '_j'
            Resulting Joined Property Name  = 'Name_j'

    .PARAMETER Type
        Type of join.  Default is AllInLeft.

        AllInLeft will have all elements from Left at least once in the output, and might appear more than once
          if the where clause is true for more than one element in right, Left elements with matches in Right are
          preceded by elements with no matches.
          SQL equivalent: outer left join (or simply left join)

        AllInRight is similar to AllInLeft.

        OnlyIfInBoth will cause all elements from Left to be placed in the output, only if there is at least one
          match in Right.
          SQL equivalent: inner join (or simply join)

        AllInBoth will have all entries in right and left in the output. Specifically, it will have all entries
          in right with at least one match in left, followed by all entries in Right with no matches in left,
          followed by all entries in Left with no matches in Right.
          SQL equivalent: full join

    .EXAMPLE
        #
        #Define some input data.

        $l = 1..5 | Foreach-Object {
            [pscustomobject]@{
                Name = "jsmith$_"
                Birthday = (Get-Date).adddays(-1)
            }
        }

        $r = 4..7 | Foreach-Object{
            [pscustomobject]@{
                Department = "Department $_"
                Name = "Department $_"
                Manager = "jsmith$_"
            }
        }

        #We have a name and Birthday for each manager, how do we find their department, using an inner join?
        Join-Object -Left $l -Right $r -LeftJoinProperty Name -RightJoinProperty Manager -Type OnlyIfInBoth -RightProperties Department


            # Name    Birthday             Department
            # ----    --------             ----------
            # jsmith4 4/14/2015 3:27:22 PM Department 4
            # jsmith5 4/14/2015 3:27:22 PM Department 5

    .EXAMPLE
        #
        #Define some input data.

        $l = 1..5 | Foreach-Object {
            [pscustomobject]@{
                Name = "jsmith$_"
                Birthday = (Get-Date).adddays(-1)
            }
        }

        $r = 4..7 | Foreach-Object{
            [pscustomobject]@{
                Department = "Department $_"
                Name = "Department $_"
                Manager = "jsmith$_"
            }
        }

        #We have a name and Birthday for each manager, how do we find all related department data, even if there are conflicting properties?
        $l | Join-Object -Right $r -LeftJoinProperty Name -RightJoinProperty Manager -Type AllInLeft -Prefix j_

            # Name    Birthday             j_Department j_Name       j_Manager
            # ----    --------             ------------ ------       ---------
            # jsmith1 4/14/2015 3:27:22 PM
            # jsmith2 4/14/2015 3:27:22 PM
            # jsmith3 4/14/2015 3:27:22 PM
            # jsmith4 4/14/2015 3:27:22 PM Department 4 Department 4 jsmith4
            # jsmith5 4/14/2015 3:27:22 PM Department 5 Department 5 jsmith5

    .EXAMPLE
        #
        #Hey!  You know how to script right?  Can you merge these two CSVs, where Path1's IP is equal to Path2's IP_ADDRESS?

        #Get CSV data
        $s1 = Import-CSV $Path1
        $s2 = Import-CSV $Path2

        #Merge the data, using a full outer join to avoid omitting anything, and export it
        Join-Object -Left $s1 -Right $s2 -LeftJoinProperty IP_ADDRESS -RightJoinProperty IP -Prefix 'j_' -Type AllInBoth |
            Export-CSV $MergePath -NoTypeInformation

    .EXAMPLE
        #
        # "Hey Warren, we need to match up SSNs to Active Directory users, and check if they are enabled or not.
        #  I'll e-mail you an unencrypted CSV with all the SSNs from gmail, what could go wrong?"

        # Import some SSNs.
        $SSNs = Import-CSV -Path D:\SSNs.csv

        #Get AD users, and match up by a common value, samaccountname in this case:
        Get-ADUser -Filter "samaccountname -like 'wframe*'" |
            Join-Object -LeftJoinProperty samaccountname -Right $SSNs `
                        -RightJoinProperty samaccountname -RightProperties ssn `
                        -LeftProperties samaccountname, enabled, objectclass

    .NOTES
        This borrows from:
            Dave Wyatt's Join-Object - http://powershell.org/wp/forums/topic/merging-very-large-collections/
            Lucio Silveira's Join-Object - http://blogs.msdn.com/b/powershell/archive/2012/07/13/join-object.aspx

        Changes:
            Always display full set of properties
            Display properties in order (left first, right second)
            If specified, add suffix or prefix to right object property names to avoid collisions
            Use a hashtable rather than ordereddictionary (avoid case sensitivity)

    .LINK
        http://ramblingcookiemonster.github.io/Join-Object/

    .FUNCTIONALITY
        PowerShell Language

    #>
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true,
                   ValueFromPipeLine = $true)]
        [AllowEmptyCollection()]
        [object[]] $Left,
        # List to join with $Left
        [Parameter(Mandatory=$true)]
        [AllowEmptyCollection()]
        [object[]] $Right,
        [Parameter(Mandatory = $true)]
        [string] $LeftJoinProperty,
        [Parameter(Mandatory = $true)]
        [string] $RightJoinProperty,
        [object[]]$LeftProperties = '*',
        # Properties from $Right we want in the output.
        # Like LeftProperties, each can be a plain name, wildcard or hashtable. See the LeftProperties comments.
        [object[]]$RightProperties = '*',
        [validateset( 'AllInLeft', 'OnlyIfInBoth', 'AllInBoth', 'AllInRight')]
        [Parameter(Mandatory=$false)]
        [string]$Type = 'AllInLeft',
        [string]$Prefix,
        [string]$Suffix
    )
    Begin
    {
        function AddItemProperties($item, $properties, $hash)
        {
            if ($null -eq $item)
            {
                return
            }
            foreach($property in $properties)
            {
                $propertyHash = $property -as [hashtable]
                if($null -ne $propertyHash)
                {
                    $hashName = $propertyHash["name"] -as [string]
                    $expression = $propertyHash["expression"] -as [scriptblock]

                    $expressionValue = $expression.Invoke($item)[0]

                    $hash[$hashName] = $expressionValue
                }
                else
                {
                    foreach($itemProperty in $item.psobject.Properties)
                    {
                        if ($itemProperty.Name -like $property)
                        {
                            $hash[$itemProperty.Name] = $itemProperty.Value
                        }
                    }
                }
            }
        }
        function TranslateProperties
        {
            [cmdletbinding()]
            param(
                [object[]]$Properties,
                [psobject]$RealObject,
                [string]$Side)
            foreach($Prop in $Properties)
            {
                $propertyHash = $Prop -as [hashtable]
                if($null -ne $propertyHash)
                {
                    $hashName = $propertyHash["name"] -as [string]
                    $expression = $propertyHash["expression"] -as [scriptblock]
                    $ScriptString = $expression.tostring()
                    if($ScriptString -notmatch 'param\(')
                    {
                        Write-Verbose "Property '$HashName'`: Adding param(`$_) to scriptblock '$ScriptString'"
                        $Expression = [ScriptBlock]::Create("param(`$_)`n $ScriptString")
                    }

                    $Output = @{Name =$HashName; Expression = $Expression }
                    Write-Verbose "Found $Side property hash with name $($Output.Name), expression:`n$($Output.Expression | out-string)"
                    $Output
                }
                else
                {
                    foreach($ThisProp in $RealObject.psobject.Properties)
                    {
                        if ($ThisProp.Name -like $Prop)
                        {
                            Write-Verbose "Found $Side property '$($ThisProp.Name)'"
                            $ThisProp.Name
                        }
                    }
                }
            }
        }
        function WriteJoinObjectOutput($leftItem, $rightItem, $leftProperties, $rightProperties)
        {
            $properties = @{}
            AddItemProperties $leftItem $leftProperties $properties
            AddItemProperties $rightItem $rightProperties $properties
            New-Object psobject -Property $properties
        }

        #Translate variations on calculated properties.  Doing this once shouldn't affect perf too much.
        foreach($Prop in @($LeftProperties + $RightProperties))
        {
            if($Prop -as [hashtable])
            {
                foreach($variation in ('n','label','l'))
                {
                    if(-not $Prop.ContainsKey('Name') )
                    {
                        if($Prop.ContainsKey($variation) )
                        {
                            $Prop.Add('Name',$Prop[$Variation])
                        }
                    }
                }
                if(-not $Prop.ContainsKey('Name') -or $Prop['Name'] -like $null )
                {
                    Throw "Property is missing a name`n. This should be in calculated property format, with a Name and an Expression:`n@{Name='Something';Expression={`$_.Something}}`nAffected property:`n$($Prop | out-string)"
                }
                if(-not $Prop.ContainsKey('Expression') )
                {
                    if($Prop.ContainsKey('E') )
                    {
                        $Prop.Add('Expression',$Prop['E'])
                    }
                }
                if(-not $Prop.ContainsKey('Expression') -or $Prop['Expression'] -like $null )
                {
                    Throw "Property is missing an expression`n. This should be in calculated property format, with a Name and an Expression:`n@{Name='Something';Expression={`$_.Something}}`nAffected property:`n$($Prop | out-string)"
                }
            }
        }
        $leftHash = @{}
        $rightHash = @{}
        # Hashtable keys can't be null; we'll use any old object reference as a placeholder if needed.
        $nullKey = New-Object psobject
        $bound = $PSBoundParameters.keys -contains "InputObject"
        if(-not $bound)
        {
            [System.Collections.ArrayList]$LeftData = @()
        }
    }
    Process
    {
        #We pull all the data for comparison later, no streaming
        if($bound)
        {
            $LeftData = $Left
        }
        Else
        {
            foreach($Object in $Left)
            {
                [void]$LeftData.add($Object)
            }
        }
    }
    End
    {
        foreach ($item in $Right)
        {
            $key = $item.$RightJoinProperty

            if ($null -eq $key)
            {
                $key = $nullKey
            }
            $bucket = $rightHash[$key]
            if ($null -eq $bucket)
            {
                $bucket = New-Object System.Collections.ArrayList
                $rightHash.Add($key, $bucket)
            }
            $null = $bucket.Add($item)
        }
        foreach ($item in $LeftData)
        {
            $key = $item.$LeftJoinProperty
            if ($null -eq $key)
            {
                $key = $nullKey
            }
            $bucket = $leftHash[$key]
            if ($null -eq $bucket)
            {
                $bucket = New-Object System.Collections.ArrayList
                $leftHash.Add($key, $bucket)
            }
            $null = $bucket.Add($item)
        }
        $LeftProperties = TranslateProperties -Properties $LeftProperties -Side 'Left' -RealObject $LeftData[0]
        $RightProperties = TranslateProperties -Properties $RightProperties -Side 'Right' -RealObject $Right[0]
        #I prefer ordered output. Left properties first.
        [string[]]$AllProps = $LeftProperties
        #Handle prefixes, suffixes, and building AllProps with Name only
        $RightProperties = foreach($RightProp in $RightProperties)
        {
            if(-not ($RightProp -as [Hashtable]))
            {
                Write-Verbose "Transforming property $RightProp to $Prefix$RightProp$Suffix"
                @{
                    Name="$Prefix$RightProp$Suffix"
                    Expression=[scriptblock]::create("param(`$_) `$_.'$RightProp'")
                }
                $AllProps += "$Prefix$RightProp$Suffix"
            }
            else
            {
                Write-Verbose "Skipping transformation of calculated property with name $($RightProp.Name), expression:`n$($RightProp.Expression | out-string)"
                $AllProps += [string]$RightProp["Name"]
                $RightProp
            }
        }
        $AllProps = $AllProps | Select -Unique
        Write-Verbose "Combined set of properties: $($AllProps -join ', ')"
        foreach ( $entry in $leftHash.GetEnumerator() )
        {
            $key = $entry.Key
            $leftBucket = $entry.Value
            $rightBucket = $rightHash[$key]
            if ($null -eq $rightBucket)
            {
                if ($Type -eq 'AllInLeft' -or $Type -eq 'AllInBoth')
                {
                    foreach ($leftItem in $leftBucket)
                    {
                        WriteJoinObjectOutput $leftItem $null $LeftProperties $RightProperties | Select $AllProps
                    }
                }
            }
            else
            {
                foreach ($leftItem in $leftBucket)
                {
                    foreach ($rightItem in $rightBucket)
                    {
                        WriteJoinObjectOutput $leftItem $rightItem $LeftProperties $RightProperties | Select $AllProps
                    }
                }
            }
        }
        if ($Type -eq 'AllInRight' -or $Type -eq 'AllInBoth')
        {
            foreach ($entry in $rightHash.GetEnumerator())
            {
                $key = $entry.Key
                $rightBucket = $entry.Value
                $leftBucket = $leftHash[$key]
                if ($null -eq $leftBucket)
                {
                    foreach ($rightItem in $rightBucket)
                    {
                        WriteJoinObjectOutput $null $rightItem $LeftProperties $RightProperties | Select $AllProps
                    }
                }
            }
        }
    }
}

function ConvertFrom-LanguageCode {
    [cmdletBinding()]
    param([string] $LanguageCode)
    $LanguageCodeDictionary = @{'1' = "Arabic"
        '4'                         = "Chinese (Simplified)?? China"
        '9'                         = "English"
        '1025'                      = "Arabic (Saudi Arabia)"
        '1026'                      = "Bulgarian"
        '1027'                      = "Catalan"
        '1028'                      = "Chinese (Traditional) Taiwan"
        '1029'                      = "Czech"
        '1030'                      = "Danish"
        '1031'                      = "German (Germany)"
        '1032'                      = "Greek"
        '1033'                      = "English (United States)"
        '1034'                      = "Spanish (Traditional Sort)"
        '1035'                      = "Finnish"
        '1036'                      = "French (France)"
        '1037'                      = "Hebrew"
        '1038'                      = "Hungarian"
        '1039'                      = "Icelandic"
        '1040'                      = "Italian (Italy)"
        '1041'                      = "Japanese"
        '1042'                      = "Korean"
        '1043'                      = "Dutch (Netherlands)"
        '1044'                      = "Norwegian (Bokmal)"
        '1045'                      = "Polish"
        '1046'                      = "Portuguese (Brazil)"
        '1047'                      = "Rhaeto-Romanic"
        '1048'                      = "Romanian"
        '1049'                      = "Russian"
        '1050'                      = "Croatian"
        '1051'                      = "Slovak"
        '1052'                      = "Albanian"
        '1053'                      = "Swedish"
        '1054'                      = "Thai"
        '1055'                      = "Turkish"
        '1056'                      = "Urdu"
        '1057'                      = "Indonesian"
        '1058'                      = "Ukrainian"
        '1059'                      = "Belarusian"
        '1060'                      = "Slovenian"
        '1061'                      = "Estonian"
        '1062'                      = "Latvian"
        '1063'                      = "Lithuanian"
        '1065'                      = "Persian"
        '1066'                      = "Vietnamese"
        '1069'                      = "Basque (Basque)"
        '1070'                      = "Serbian"
        '1071'                      = "Macedonian (FYROM)"
        '1072'                      = "Sutu"
        '1073'                      = "Tsonga"
        '1074'                      = "Tswana"
        '1076'                      = "Xhosa"
        '1077'                      = "Zulu"
        '1078'                      = "Afrikaans"
        '1080'                      = "Faeroese"
        '1081'                      = "Hindi"
        '1082'                      = "Maltese"
        '1084'                      = "Scottish Gaelic (United Kingdom)"
        '1085'                      = "Yiddish"
        '1086'                      = "Malay (Malaysia)"
        '2049'                      = "Arabic (Iraq)"
        '2052'                      = "Chinese (Simplified) PRC"
        '2055'                      = "German (Switzerland)"
        '2057'                      = "English (United Kingdom)"
        '2058'                      = "Spanish (Mexico)"
        '2060'                      = "French (Belgium)"
        '2064'                      = "Italian (Switzerland)"
        '2067'                      = "Dutch (Belgium)"
        '2068'                      = "Norwegian (Nynorsk)"
        '2070'                      = "Portuguese (Portugal)"
        '2072'                      = "Romanian (Moldova)"
        '2073'                      = "Russian (Moldova)"
        '2074'                      = "Serbian (Latin)"
        '2077'                      = "Swedish (Finland)"
        '3073'                      = "Arabic (Egypt)"
        '3076'                      = "Chinese Traditional (Hong Kong SAR)"
        '3079'                      = "German (Austria)"
        '3081'                      = "English (Australia)"
        '3082'                      = "Spanish (International Sort)"
        '3084'                      = "French (Canada)"
        '3098'                      = "Serbian (Cyrillic)"
        '4097'                      = "Arabic (Libya)"
        '4100'                      = "Chinese Simplified (Singapore)"
        '4103'                      = "German (Luxembourg)"
        '4105'                      = "English (Canada)"
        '4106'                      = "Spanish (Guatemala)"
        '4108'                      = "French (Switzerland)"
        '5121'                      = "Arabic (Algeria)"
        '5127'                      = "German (Liechtenstein)"
        '5129'                      = "English (New Zealand)"
        '5130'                      = "Spanish (Costa Rica)"
        '5132'                      = "French (Luxembourg)"
        '6145'                      = "Arabic (Morocco)"
        '6153'                      = "English (Ireland)"
        '6154'                      = "Spanish (Panama)"
        '7169'                      = "Arabic (Tunisia)"
        '7177'                      = "English (South Africa)"
        '7178'                      = "Spanish (Dominican Republic)"
        '8193'                      = "Arabic (Oman)"
        '8201'                      = "English (Jamaica)"
        '8202'                      = "Spanish (Venezuela)"
        '9217'                      = "Arabic (Yemen)"
        '9226'                      = "Spanish (Colombia)"
        '10241'                     = "Arabic (Syria)"
        '10249'                     = "English (Belize)"
        '10250'                     = "Spanish (Peru)"
        '11265'                     = "Arabic (Jordan)"
        '11273'                     = "English (Trinidad)"
        '11274'                     = "Spanish (Argentina)"
        '12289'                     = "Arabic (Lebanon)"
        '12298'                     = "Spanish (Ecuador)"
        '13313'                     = "Arabic (Kuwait)"
        '13322'                     = "Spanish (Chile)"
        '14337'                     = "Arabic (U.A.E.)"
        '14346'                     = "Spanish (Uruguay)"
        '15361'                     = "Arabic (Bahrain)"
        '15370'                     = "Spanish (Paraguay)"
        '16385'                     = "Arabic (Qatar)"
        '16394'                     = "Spanish (Bolivia)"
        '17418'                     = "Spanish (El Salvador)"
        '18442'                     = "Spanish (Honduras)"
        '19466'                     = "Spanish (Nicaragua)"
        '20490'                     = "Spanish (Puerto Rico)"
    }
    $Output = $LanguageCodeDictionary[$LanguageCode]
    if ($Output) { $Output } else { "Unknown (Undocumented)" }
}

# Set logs path and other vars
$computer = ($env:computername).ToLower()
if($device_name -notmatch "\S") {
    $device_name = "$computer"                    # Value for device_name if left empty or white space
    Write-Host -ForegroundColor Yellow "Missing -DeviceName parameter. Using default: $Device_Name"
}
if($logpath -notmatch "\S") {
   $logpath = $pwd.ToString()+"\$computer.out"    # Value for logpath if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -logpath parameter. Using default: $logpath"
}
if($logf -notmatch "\S") {
   $logf = "$computer.log"                        # Value for logf if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -logf parameter. Using default: $logf"
}
if($ZipLog -notmatch "\S") {
   $ZipLog = $True                                # Value for logf if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -ZipLog parameter. Using default: $ZipLog"
}
if($account -notmatch "\S") {
   $account = "SDE"                               # Value for account if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -account parameter. Using default: $account"
}
if($blueid -notmatch "\S") {
   $blueid = "BAC9999999"                         # Value for blueID if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -blueid parameter. Using default: $blueid"
}
if($chipid -notmatch "\S") {
   $chipid = "MyChip"                            # Value for mychip if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -chipid parameter. Using default: $chipid"
}
if($location -notmatch "\S") {
   $location = "Tucson"                          # Value for location if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -location parameter. Using default: $location"
}
if($satteam -notmatch "\S") {
   $satteam = "Compute"                          # Value for satteam if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -satteam parameter. Using default: $satteam"
}
if($hwswdomain -notmatch "\S") {
   $hwswdomain = "Compute"                       # Value for hwswdomain if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -hwswdomain parameter. Using default: $hwswdomain"
}
if($SATmode -notmatch "\S") {
   $SATmode = $false                             # Value for SATmode if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -SATmode parameter. Using default: $SATmode"
}
if($udcmode -notmatch "\S") {
   $udcmode = $false                             # Value for SATmode if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -udcmode parameter. Using default: $udcmode"
}
# Policy and Engine at Remote Collector
if($tpchcversion -notmatch "\S") {
   $tpchcversion = "2.11.0"                       # Value for tpchversion if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -tpchversion parameter. Using default: $tpchcversion"
}
 # Code level for this script
if($buildversion -notmatch "\S") {
   $buildversion	= "2.11.0.20250402"           # Value for buildversion if left empty or white space
   Write-Host -ForegroundColor Yellow "Missing -buildversion parameter. Using default: $buildversion"
}
# SATHC variables

$tpchc_description = "Microsoft_OS_Windows"      # Value for description
$tpchc_identifier = "None"                       # Value for identifier

$log_to_logfile = $true                          # Always generate log file
$localfolder = Get-Location
$logdir = "$localfolder\$computer-log"
$crt = 0                                         # Variable used for numbering in log file

# Cleaning old logs
if (test-path $logdir){
    Remove-Item -Recurse $logdir | Out-Null
    New-Item -Path $logdir -ItemType Directory | Out-Null
}
else{
    New-Item -Path $logdir -ItemType Directory | Out-Null
}

Remove-Item $localfolder\$computer.out -ErrorAction SilentlyContinue
Remove-Item $localfolder\$computer.log -ErrorAction SilentlyContinue

# Define some variables $HostIP, $os widely used
$HostIP = (
    Get-CimInstance Win32_NetworkAdapterConfiguration |
    Where-Object {$_.IPAddress -ne $null -and $_.DefaultIPGateway -ne $null}
).IPAddress[0]

$os = (Get-CimInstance Win32_OperatingSystem).Caption

# Get Features
Import-Module ServerManager
$features = Get-WindowsFeature | Where-Object {$_.Installed -eq "True"} | Select-Object @{N='MachineName';E={$computer}},Name,DisplayName

# Define out file as stream output
$Global:file_stream_output = New-Object System.IO.StreamWriter $LogPath, $true

# Create always present segments. These can be modified at UDC level
If ($SATmode -eq $false) {
    $file_stream_output.WriteLine("#### <devicelist_cfg>")
    $file_stream_output.WriteLine('"Devicename";"Deviceaddress";"Devicetype"')
    $file_stream_output.WriteLine("""$device_name"";""$HostIP"";""$tpchc_description""")
    $file_stream_output.WriteLine("#### </devicelist_cfg>")

    $file_stream_output.WriteLine("#### <tpchc_cfg>")
    $file_stream_output.WriteLine('"tpchc_version";"build_version";"blue_id";"chip_id";"account";"location";"tpchc_description";"tpchc_identifier";"satteam";"hwswdomain"')
    $file_stream_output.WriteLine("""$tpchcversion"";""$buildversion"";""$blueid"";""$chipid"";""$account"";""$location"";""$tpchc_description"";""$tpchc_identifier"";""$satteam"";""$hwswdomain""")
    $file_stream_output.WriteLine("#### </tpchc_cfg>")

    $file_stream_output.WriteLine("#### <policy_cfg>")
    $file_stream_output.WriteLine("#### </policy_cfg>")
}

# Create cacf_cfg segment when the collector is run standalone
if ($udcmode -eq $false) {
    $timestamp = get-date -format "yyyyMMdd-HHmmss"
    $OS = Get-CimInstance -Class Win32_OperatingSystem
    $OS_Version = $OS.Version
    $PowerShell_Version = $PSVersionTable.PSVersion.tostring()
    $iso8601DateTime = Get-Date -Format "yyyy-MM-ddTHH:mm:sszzz"
    $file_stream_output.WriteLine("#### <cacf_cfg>")
    $file_stream_output.WriteLine('"collected_on";"timestamp";"gsma_code";"tower_version";"os_distribution";"os_version";"ansible_version";"python_version";"powershell_version";"udc_version";"healthcheck_timestamp_utc"')
    $file_stream_output.WriteLine("""$computer"";""$timestamp"";""$account"";"""";""Windows"";""$OS_Version"";"""";""0"";""$PowerShell_Version"";"""";""$iso8601DateTime""")
    $file_stream_output.WriteLine("#### </cacf_cfg>")
}

<#
{% if 'Windows_SystemInfo' in check_list or 'all' in check_list %}
# System information
##########################################################################>
$crt++
Write-Output "$crt. $computer - System Information"
$file_stream_output.WriteLine("#### <Windows_SystemInfo>")
MsgPrint "info" "info $crt. $computer - System Information"

$SystemInfo = New-Object -TypeName PSobject
$computerSystem = Get-CimInstance -Class Win32_ComputerSystem
$computerSystemProduct = Get-CimInstance -Class Win32_ComputerSystemProduct
$computerBIOS = Get-CimInstance -Class Win32_BIOS
$computerOS = Get-CimInstance -Class Win32_OperatingSystem
$computerCPU = Get-CimInstance -Class Win32_Processor
$DomainRole = ("Standalone Workstation","Member Workstation","Standalone Server","Member Server","Backup Domain Controller","Primary Domain Controller")
# set up the different possible types of licenses in an array:
$licenseStatus=@{0="Unlicensed"; 1="Licensed"; 2="OOBGrace"; 3="OOTGrace"; 4="NonGenuineGrace"; 5="Notification"; 6="ExtendedGrace"}
# Now get the license details and assign the object to $r
$r = Get-CimInstance -Class SoftwareLicensingProduct | Where-Object {$_.ApplicationID -eq "55c92734-d682-4d71-983e-d6ec3f16059f" -AND $_.PartialProductKey -ne $null}
$PageFileResults = Get-CimInstance -Class Win32_PageFileUsage
$OSLanguage = ConvertFrom-LanguageCode(($computerOS.OSLanguage).ToString())
$Locale = ConvertFrom-LanguageCode(([System.Convert]::ToInt32($computerOS.Locale,16)).ToString())

$SystemInfo | Add-Member -MemberType NoteProperty -Name "MachineName" -Value $computerSystem.Name
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Manufacturer" -Value $computerSystem.Manufacturer
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Model" -Value $computerSystem.Model
$SystemInfo | Add-Member -MemberType NoteProperty -Name "OperatingSystem" -Value $computerOS.caption
$SystemInfo | Add-Member -MemberType NoteProperty -Name "OperatingSystem ServicePack" -Value $computerOS.ServicePackMajorVersion
$SystemInfo | Add-Member -MemberType NoteProperty -Name "BuildNumber" -Value $computerOS.BuildNumber
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Version" -Value $computerOS.Version
$SystemInfo | Add-Member -MemberType NoteProperty -Name "InstallDate" -value $ComputerOS.InstallDate.ToString()
$SystemInfo | Add-Member -MemberType NoteProperty -Name "License" -Value $licenseStatus[[int]$r.LicenseStatus]
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Uptime" -value  $computerOS.LastBootUpTime.ToString()
$SystemInfo | Add-Member -MemberType NoteProperty -Name "BootDevice" -Value $computerOS.BootDevice
$SystemInfo | Add-Member -MemberType NoteProperty -Name "SystemDevice" -Value $computerOS.SystemDevice
$SystemInfo | Add-Member -MemberType NoteProperty -Name "SystemDirectory" -Value $computerOS.SystemDirectory
$SystemInfo | Add-Member -MemberType NoteProperty -Name "WindowsDirectory" -Value $computerOS.WindowsDirectory
$SystemInfo | Add-Member -MemberType NoteProperty -Name "OSArchitecture" -Value $computerOS.OSArchitecture
$SystemInfo | Add-Member -MemberType NoteProperty -Name "PowerShellVersion" -Value $PSVersionTable.PSVersion.tostring()
$SystemInfo | Add-Member -MemberType NoteProperty -Name "CurrentTimeZone" -Value $computerOS.CurrentTimeZone
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Debug" -Value $computerOS.Debug
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Distributed" -Value $computerOS.Distributed
$SystemInfo | Add-Member -MemberType NoteProperty -Name "EncryptionLevel" -Value $computerOS.EncryptionLevel
$SystemInfo | Add-Member -MemberType NoteProperty -Name "DNS Host Name" -Value $computerSystem.DNSHostName
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Domain Role" -Value $DomainRole[$computerSystem.DomainRole]
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Roles" -Value ($computerSystem.Roles -join ',')
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Serial Number" -Value $computerBIOS.SerialNumber

If ($computerCPU -is [array]) {
    $SystemInfo | Add-Member -MemberType NoteProperty -Name "CPU Array" -Value $computerCPU.Name[0]
} else {
    $SystemInfo | Add-Member -MemberType NoteProperty -Name "CPU" -Value $computerCPU.Name
}
If ($computerCPU -is [array]) {
    $SystemInfo | Add-Member -MemberType NoteProperty -Name "CPU cores" -Value ($computerCPU.NumberOfCores | Measure-Object -sum).sum
} else {
    $SystemInfo | Add-Member -MemberType NoteProperty -Name "CPU cores" -Value $computerCPU.NumberOfCores
}
If ($computerCPU -is [array]) {
    $SystemInfo | Add-Member -MemberType NoteProperty -Name "CPU LogicalProcessors" -Value ($computerCPU.NumberOfLogicalProcessors | Measure-Object -sum).sum
} else {
    $SystemInfo | Add-Member -MemberType NoteProperty -Name "CPU LogicalProcessors" -Value $computerCPU.NumberOfLogicalProcessors
}

$SystemInfo | Add-Member -MemberType NoteProperty -Name "RAM (GB)" -Value ([math]::Round($computerSystem.TotalPhysicalMemory/1GB,2))
$SystemInfo | Add-Member -MemberType NoteProperty -Name "PageFilePath" -Value ($PageFileResults.Description -join ',')
$SystemInfo | Add-Member -MemberType NoteProperty -Name "AutoManagedPageFile" -Value $computerSystem.AutomaticManagedPagefile
$SystemInfo | Add-Member -MemberType NoteProperty -Name "PageFileSize(MB)" -Value ($PageFileResults.AllocatedBaseSize | Measure-object -sum).sum
$SystemInfo | Add-Member -MemberType NoteProperty -Name "PageFileUsage(MB)" -Value ($PageFileResults.CurrentUsage | Measure-object -sum).sum
$SystemInfo | Add-Member -MemberType NoteProperty -Name "PageFilePeakUsage(MB)" -Value ($PageFileResults.PeakUsage | Measure-object -sum).sum
$SystemInfo | Add-Member -MemberType NoteProperty -Name "TempPageFileInUse" -Value ($PageFileResults.TempPageFile | Measure-object -sum).sum
$SystemInfo | Add-Member -MemberType NoteProperty -Name "ProductKeyChannel" -Value $r.ProductKeyChannel
$SystemInfo | Add-Member -MemberType NoteProperty -Name "UUID" -Value $computerSystemProduct.UUID
$SystemInfo | Add-Member -MemberType NoteProperty -Name "FQDN" -Value $([System.Net.Dns]::GetHostByName($env:computerName).HostName)
$SystemInfo | Add-Member -MemberType NoteProperty -Name "OSLanguage" -Value $OSLanguage
$SystemInfo | Add-Member -MemberType NoteProperty -Name "Locale" -Value $Locale

$SystemInfo | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_SystemInfo>")


<#
{% endif %}

{% if ('Windows_DiskInfo' in check_list or 'all' in check_list) and '-Windows_DiskInfo' not in check_list %}
# Disk drives information
##########################################################################>
$crt++
Write-Output "$crt. $computer - Disk drives information"
MsgPrint "info" "info $crt. $computer - Disk drives information"
$file_stream_output.WriteLine("#### <Windows_DiskInfo>")
$Disks = Get-CimInstance Win32_LogicalDisk -Filter drivetype=3 |
Select-Object @{n="MachineName";e={$Computer}},DeviceID,VolumeName, `
@{n="SizeGb";e={[math]::Ceiling($_.Size/1GB)}},`
@{n="FreeSpaceGb";e={[math]::Round($_.FreeSpace/1GB,2)}},`
@{n="FreeSpace(%)";e={(([math]::Round($_.FreeSpace/1GB,2)/[math]::Round($_.Size/1GB,2)).tostring("P")).Replace(" %","")}},VolumeSerialNumber,Description, Compressed, VolumeDirty, SupportsDiskQuotas
foreach ($item in $Disks) {
    $drive = $item.DeviceID
    $DiskQueueLength = ([math]::Round(((Get-Counter "\logicalDisk($drive)\Avg. Disk Queue Length").CounterSamples.CookedValue),2))
    foreach ($obj in $item) {
        $obj | Add-Member -MemberType NoteProperty -Name 'DiskQueueLength' -Value $DiskQueueLength
    }
}
$Disks | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_DiskInfo>")

<#
{% endif %}

{% if ('Windows_VolumeInfo' in check_list or 'all' in check_list) and '-Windows_VolumeInfo' not in check_list %}
#Volume drives information
##########################################################################>
$crt++
Write-Output "$crt. $computer - Volumes drives infomation"
MsgPrint "info" "info $crt. $computer - Volume drives information"
$file_stream_output.WriteLine("#### <Windows_VolumeInfo>")
try {
  $volinfo = Get-Disk | select *
  $volinfo | Select-Object @{N="MachineName";E={$Computer}},AdapterSerialNumber,AllocatedSize,BootFromDisk,BusType,DiskNumber,FirmwareVersion,FriendlyName,Guid,HealthStatus, `
  IsBoot,IsClustered,IsHighlyAvailable,IsOffline,IsReadOnly,IsScaleOut,IsSystem,LargestFreeExtent,Location,LogicalSectorSize,Manufacturer,Model,Number,NumberOfPartitions, `
  OfflineReason,OperationalStatus,PartitionStyle,PhysicalSectorSize,ProvisioningType,PSComputerName,SerialNumber,Signature,Size,UniqueId,UniqueIdFormat | `
  ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch {
  MsgPrint "error" "error $crt. $computer - Volume drives information"
}
$file_stream_output.WriteLine("#### </Windows_VolumeInfo>")

<#
{% endif %}

{% if ('Windows_Error_Logs' in check_list or 'all' in check_list) and '-Windows_Error_Logs' not in check_list %}
# System & Application log
##########################################################################>
$crt++
Write-Output "$crt. $computer - System & Application logs"
MsgPrint "info" "info $crt. $computer - System & Application logs"
$file_stream_output.WriteLine("#### <Windows_Error_Logs>")
$LogObj = @()
$Logs = "System","Application"
foreach ($Log in $Logs){
    Try{
        $TempObj = Get-WinEvent -FilterHashtable @{ LogName=$Log } -Maxevents 100 | `
        Where-Object -FilterScript {($_.Level -eq 2) -or ($_.Level -eq 3)} | `
        Select-Object @{Name="MachineName";Expression = {$computer}},
        Logname, Id, level, ProviderName, TimeCreated ,@{Name="UserName";Expression = `
        {$_.UserId.translate([System.Security.Principal.NTAccount]).value}}
        $TempObj | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}

        }
    Catch{
       #No events in the log
        $file_stream_output.WriteLine("""$computer"";""no events in $log log""")
    }
}
$file_stream_output.WriteLine("#### </Windows_Error_Logs>")

<#
{% endif %}

{% if ('Windows_Drivers' in check_list or 'all' in check_list) and '-Windows_Drivers' not in check_list %}
#Drivers
##########################################################################>
$crt++
Write-Output "$crt. $computer - Drivers"
MsgPrint "info" "info $crt. $computer - Drivers"
$file_stream_output.WriteLine("#### <Windows_Drivers>")
$drivers = Get-CimInstance Win32_PnPSignedDriver | Select-Object PSComputerName,devicename, driverversion
$drivers | Select-Object @{N="MachineName";E={$Computer}},devicename, driverversion | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_Drivers>")

<#
{% endif %}


{% if ('Windows_IPConfig' in check_list or 'all' in check_list) and '-Windows_IPConfig' not in check_list %}
# IP Configuration
##########################################################################>
$crt++
Write-Output "$crt. $computer - IP Configuration"
MsgPrint "info" "info $crt. $computer - IP Configuration"
$file_stream_output.WriteLine("#### <Windows_IPConfig>")
$ipconfig = Get-CimInstance Win32_NetworkAdapterConfiguration | Where-Object {$_.IPAddress -ne $null}
$ipconfig | Select-Object @{N='MachineName';E={$computer}},@{N='InterfaceName';E={(Get-NetAdapter -InterfaceIndex $_.InterfaceIndex).Name}}, Description, @{N='DNSDomainSuffixSearchOrder';E={($_.DNSDomainSuffixSearchOrder) -join ','}}, MACAddress, InterfaceIndex,`
@{N='IPAddress';E={($_.IPAddress)[0]}}, @{N='IPSubnet';E={($_.IPSubnet) -join ','}}, `
@{N='DefaultIPGateway';E={($_.DefaultIPGateway) -join ','}},@{N='DNSServerSearchOrder';E={($_.DNSServerSearchOrder) -join ','}},`
DHCPEnabled, @{N='DHCPLeaseExpires';E={[Management.ManagementDateTimeConverter]::ToDateTime($_.DHCPLeaseExpires)}}, `
@{N='DHCPLeaseObtained';E={[Management.ManagementDateTimeConverter]::ToDateTime($_.DHCPLeaseObtained)}}, DHCPServer | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_IPConfig>")

<#
{% endif %}

{% if ('Windows_IP_Routes' in check_list or 'all' in check_list) and '-Windows_IP_Routes' not in check_list %}
# IP Routes
##########################################################################>
$crt++
Write-Output "$crt. $computer - IP routes"
MsgPrint "info" "info $crt. $computer - IP routes"
$file_stream_output.WriteLine("#### <Windows_IP_Routes>")
try {
    $ObjRoute = Get-NetRoute
    $ObjRoute = $ObjRoute | Add-Member -NotePropertyMembers @{MachineName="$computer"} -PassThru
    $ObjRoute | ConvertTo-Csv -delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch {
    MsgPrint "Warning" "Warning $crt. $computer - IP routes - Get-Netroute error"
    $file_stream_output.WriteLine("Error in running get-netroute")
}
$file_stream_output.WriteLine("#### </Windows_IP_Routes>")

<#
{% endif %}

{% if ('Windows_DNS' in check_list or 'all' in check_list) and '-Windows_DNS' not in check_list %}
# IP Routes
##########################################################################>

$crt++
Write-Output "$crt. $computer - DNS Configuration"
MsgPrint "info" "info $crt. $computer - DNS Configuration"
$file_stream_output.WriteLine("#### <Windows_DNS>")
$network_adapters = Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter IPEnabled=TRUE -erroraction 'silentlycontinue'
$out = @()
$dom = (Get-WmiObject -Class Win32_ComputerSystem).Domain
$network_adapters | Select-Object DNSServerSearchOrder | ForEach-Object {
    -split $_.DNSServerSearchOrder | ForEach-Object {
        if ($_) {
                $resolve = Resolve-DnsName -Name $dom -Server $_ -QuickTimeout -NoRecursion -erroraction 'silentlycontinue'
                $dns_rec =  $resolve.count
                $out += [PSCustomObject]@{
                    "DNS" = $_
                    "Domain" = $dom
                    "Records" = $dns_rec
                    }
           }
     }
}

$out | ConvertTo-Csv -delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_DNS>")

<#
{% endif %}

{% if ('Windows_Last_Update' in check_list or 'all' in check_list) and '-Windows_Last_Update' not in check_list %}
# Windows Updates installed
##########################################################################>
# Operation can take following values
# 1 = Installation
# 2 = Uninstallation
# 3 = Other
# Resultcode can take following values
# 0 = Not Started
# 1 = In Progress
# 2 = Succeeded
# 3 = Succeeded With Errrors
# 4 = Failed
# 5 = Aborted

$crt++
Write-Output "$crt. $computer - Windows Updates"
MsgPrint "info" "info $crt. $computer - Windows Updates"

$file_stream_output.WriteLine("#### <Windows_Patches>")
$PatchList1 = @()
$PatchList2 = @()

try {
    $PatchList1 = Get-CimInstance -ClassName win32_quickfixengineering | Select HotFixID,InstalledOn,InstalledBy,@{N='FromQuickFix';E={"X"}} | Sort-Object -Property HotFixID -Descending
}
catch {
    MsgPrint "error" "Windows Patches via win32_quickfixengineering"
}

$WindowsUpdatesAll = @()
$WindowsUpdates = @()

try{
    $Session = New-Object -ComObject "Microsoft.Update.Session"
    $Searcher = $Session.CreateUpdateSearcher()
    $historyCount = $Searcher.GetTotalHistoryCount()
    $UpdateHistory = $Searcher.QueryHistory(0, $historyCount)
    $KBs = @()
    foreach ($Update in $UpdateHistory) {
        [regex]::match($Update.Title,'(KB[0-9]{6,7})').value | Where-Object {$_ -ne ""} | ForEach-Object {
            $KBs += [PSCustomObject]@{
                "HotFixID" = $_
                "InstalledOn" = $Update.Date
                "Operation" = $Update.Operation
                "ResultCode" = $Update.Resultcode
                "Title" = $Update.Title
                "FromHistory" = "X"
            }
        }
    }
    $WindowsUpdatesAll = $KBs | Sort-Object -Property HotFixID -Descending
    $PatchList2 = $WindowsUpdatesAll | Where-Object {$_.Title -notlike "*Microsoft Defender*"} -ErrorAction Stop
    }
   catch{
    MsgPrint "error" "error $crt. $computer - Windows Update History"
}

$join = Join-Object -Left $PatchList1 -Right $PatchList2 -LeftJoinProperty HotFixID -RightJoinProperty HotFixID -Type AllInBoth
$join = $join | Select-Object  @{N='MachineName';E={$Computer}},HotFixID,FromQuickFix,FromHistory,InstalledOn,Title,Operation,ResultCode,InstalledBy | Sort-Object InstalledOn -Descending
$join | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | Foreach-Object { $file_stream_output.WriteLine($_) }
$file_stream_output.WriteLine("#### </Windows_Patches>")
$file_stream_output.WriteLine("#### <Windows_Last_Update>")
$file_stream_output.WriteLine("""MachineName"";""LastUpdate"";""DaysSinceUpdate"";""LastReboot"";""DaysSinceReboot""")
If ($null -ne $join){
    try{
        $LastUpdate = ($join | Sort-Object InstalledOn | Select-Object -last 1).InstalledOn
        $lastBootTime= (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
        $DaysSinceReboot = (New-TimeSpan -Start $lastBootTime -End (Get-Date)).Days
        $DaysSinceUpdate = (New-TimeSpan -Start $LastUpdate -End (Get-Date)).Days
        $file_stream_output.WriteLine("""$computer"";""$LastUpdate"";""$DaysSinceUpdate"";""$lastBootTime"";""$DaysSinceReboot""")
    }
    catch{
        $file_stream_output.WriteLine("""$computer"";""Error on get lastboot time"";""-1""")
    }
}
Else{
    $file_stream_output.WriteLine("""$computer"";""No updates found"";""-1""")
}
$file_stream_output.WriteLine("#### </Windows_Last_Update>")

<#
{% endif %}

{% if ('Windows_Services' in check_list or 'all' in check_list) and '-Windows_Services' not in check_list %}
# Services
##########################################################################>
$crt++
Write-Output "$crt. $computer - Windows Services"
MsgPrint "info" "info $crt. $computer - Windows Services"
$file_stream_output.WriteLine("#### <Windows_Services>")
$out=@()
Get-CIMInstance Win32_Service | sort-object -property Name | foreach-object {
        $Status = (&{if($_.started) {"Running"} Else {"Stopped"}})
        $StartType = (&{if($_.StartMode -eq "Auto") {"Automatic"} Else {$_.StartMode}})
        if (Test-Path -Path "HKLM:\SYSTEM\CurrentControlSet\Services\$($_.Name)\TriggerInfo\") {
            $StartType = $StartType + " (Trigger Start)"
        }
        $Name = $_.Name
        $DisplayName = $_.caption
        $StartName = $_.startname
        $out += [PSCustomObject]@{
              "MachineName" = $computer
              "Status" = $Status
              "StartType" = $StartType
              "Name" = $Name
              "DisplayName" = $DisplayName
              "LogonAccount" = $StartName
        }
}
$out | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_Services>")

<#
{% endif %}

{% if ('Windows_Programs' in check_list or 'all' in check_list) and '-Windows_Programs' not in check_list %}
# Programs installed
##########################################################################>
$crt++
Write-Output "$crt. $computer - Programs installed"
MsgPrint "info" "info $crt. $computer - Programs installed"
$file_stream_output.WriteLine("#### <Windows_Programs>")
Try{
    Get-Software -ErrorAction SilentlyContinue | Select-Object -property MachineName,Publisher,DisplayName,Version,InstallDate | Sort-Object DisplayName | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch{
    MsgPrint "Error" "Error $crt. $computer - Programs installed"
    Write-Output "An error occurred:"
    Write-Output $_
}
$file_stream_output.WriteLine("#### </Windows_Programs>")

<#
{% endif %}

{% if ('Windows_SMB_Server' in check_list or 'Windows_SMB_shares' in check_list or 'all' in check_list) and '-Windows_SMB_Server' not in check_list %}
#>

# Check if SMB v1/2 is enabled
##########################################################################

#https://support.microsoft.com/en-us/help/2696547/detect-enable-disable-smbv1-smbv2-smbv3-in-windows-and-windows-server
#https://learn.microsoft.com/en-us/windows-server/storage/file-server/troubleshoot/detect-enable-and-disable-smbv1-v2-v3?tabs=server
$crt++
If ($os -like "*2008*"){
    Write-Output "$crt. $computer - SMB v1/2 check"
    MsgPrint "info" "info $crt. $computer - SMB v1/2 check Windows 2008"
    $file_stream_output.WriteLine("#### <Windows_SMB_Server>")
    $file_stream_output.WriteLine("""MachineName"";""SMBstate""")
    $SMB1 = Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters:SMB1"
    if ($SMB1 -eq 0) {
        $file_stream_output.WriteLine("""$computer"";""SMB1 disabled""")
        } else {
        $file_stream_output.WriteLine("""$computer"";""SMB1 enabled""")
    }
    $SMB2 = Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters:SMB2"
    if ($SMB2 -eq 0) {
        $file_stream_output.WriteLine("""$computer"";""SMB2 disabled""")
        } else {
        $file_stream_output.WriteLine("""$computer"";""SMB2 enabled""")
    }
    $file_stream_output.WriteLine("#### </Windows_SMB_Server>")
    # Samba shares
    ##########################################################################
    Write-Output "$crt. $computer - Windows 2008 Samba shares"
    MsgPrint "info" "info $crt. $computer - Windows 2008 Samba shares"
}
Else{
    # Check if SMB v1.0 enabled
    ##########################################################################
    Write-Output "$crt. $computer - SMB v1 & SMB v2 check"
    MsgPrint "info" "info $crt. $computer - SMB v1 & SMB v2 check"
    $file_stream_output.WriteLine("#### <Windows_SMB_Server>")
    $file_stream_output.WriteLine("""MachineName"";""SMBstate""")
    $SMB1 = Get-SmbServerConfiguration | Select-Object EnableSMB1Protocol -ExpandProperty EnableSMB1Protocol
    If ($SMB1 -eq $True){
        $file_stream_output.WriteLine("""$computer"";""SMB1 enabled""")
    }
    Else{
        $file_stream_output.WriteLine("""$computer"";""SMB1 disabled""")
    }

    # Check if SMB v2.0 enabled
    ##########################################################################
    $SMB2 = Get-SmbServerConfiguration | Select-Object EnableSMB2Protocol -ExpandProperty EnableSMB2Protocol
    If ($SMB2 -eq $True){
        $file_stream_output.WriteLine("""$computer"";""SMB2 enabled""")
    }
    Else{
        $file_stream_output.WriteLine("""$computer"";""SMB2 disabled""")
    }
    $file_stream_output.WriteLine("#### </Windows_SMB_Server>")

    # Samba Shares
    ##########################################################################
    $crt++
    Write-Output "$crt. $computer - SMB shares"
    MsgPrint "info" "info $crt. $computer - SMB shares"
    $file_stream_output.WriteLine("#### <Windows_SMB_shares>")
    $SmbShares = Get-SmbShare |
    Select-Object @{N="MachineName";E = {$computer}},Description, EncryptData, Name, Path, Scoped, ScopeName, SecurityDescriptor, ShadowCopy, Special, Temporary, Volume, ShareState, AvailabilityType, ShareType, FolderEnumerationMode, CachingMode, SmbInstance, CATimeout, ConcurrentUserLimit, ContinuouslyAvailable, CurrentUsers
    $SmbShares | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
    $file_stream_output.WriteLine("#### </Windows_SMB_shares>")
}
<#
{% endif %}

{% if ('Windows_Features' in check_list or 'all' in check_list) and '-Windows_Features' not in check_list %}
# Windows Features
##########################################################################>
$crt++
Write-Output "$crt. $computer - Windows Features Installed"
MsgPrint "info" "info $crt. $computer - Windows Features Installed"
$file_stream_output.WriteLine("#### <Windows_Features>")
$features | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_Features>")

<#
{% endif %}

{% if ('Windows_Certificates' in check_list or 'all' in check_list) and '-Windows_Certificates' not in check_list %}
# Certificates expiration
##########################################################################>
$crt++
Write-Output "$crt. $computer - Certificates expiration"
MsgPrint "info" "info $crt. $computer - Certificates expiration"
$file_stream_output.WriteLine("#### <Windows_Certificates>")
$file_stream_output.WriteLine("""MachineName"";""Certif_Expired"";""Certif_Exp_30Days"";""Certif_active""")
$certificates = Get-ChildItem -Path Cert:\LocalMachine\My | Select-Object Subject, HasPrivateKey, @{n="SignatureAlgorithm";e={$_.SignatureAlgorithm.FriendlyName}}, Issuer, NotAfter, NotBefore, SerialNumber, Thumbprint
$certExpired = @()
$certActive = @()
$certSoonExpire = @()
$certExpiredNr = 0
$certActiveNr = 0
$certSoonExpireNr = 0

ForEach ($cert in $certificates){
    if ($cert.NotAfter -lt (Get-Date)){
        #Certificate expired
        $certExpired += $cert
        $certExpiredNr += 1
    }
    else{
        #Certificate active
        $certActive += $cert
        $certActiveNr += 1
    }
}

foreach ($cert in $certActive){
    if ($cert.NotAfter -le ((Get-Date).AddDays(30))){
        $certSoonExpire += $cert
        $certSoonExpireNr += 1
    }
}

#Certificates expired - uncomment if needed
#if ($null -ne $certExpired){
#   $certExpired | Export-Csv -NoTypeInformation -Path $logdir\$crt-Certificates-Expired.csv
#}

#Certificates expire in 30 days or less - uncomment if needed
#if ($null -ne $certSoonExpire){
#    $certSoonExpire | Export-Csv -NoTypeInformation -Path $logdir\$crt-Certificates-Expire-Soon.csv
#}
$file_stream_output.WriteLine("""$computer"";""$certExpiredNr"";""$certSoonExpireNr"";""$certActiveNr""")
$file_stream_output.WriteLine("#### </Windows_Certificates>")

<#
{% endif %}

{% if ('Windows_AllCertificates' in check_list or 'all' in check_list) and '-Windows_AllCertificates' not in check_list %}
# All Certificates summary
##########################################################################>
$crt++
Write-Output "$crt. $computer - All Certificates summary"
MsgPrint "info" "info $crt. $computer - All Certificates summary"
$file_stream_output.WriteLine("#### <Windows_AllCertificates>")
#Get-ChildItem Cert:LocalMachine/My | select-object @{n="MachineName";e={$computer}},Subject,NotBefore,@{n="ValidDays";e={($_.NotAfter-$_.NotBefore).days}},NotAfter,@{n="DaysToExp";e={($_.NotAfter-(Get-Date)).Days}},Thumbprint,Issuer,@{n="SignatureAlgorithm";e={$_.SignatureAlgorithm.FriendlyName}},@{n="PublicKeySize";e={$_.PublicKey.key.keysize}},@{n="ExtKeyUsage";e={$_.extensions.enhancedkeyusages.friendlyname -join ','}},HasPrivateKey,FriendlyName | ConvertTo-Csv -Delimiter ";" -NoTypeInformation |foreach-object {$file_stream_output.WriteLine($_)}
Get-ChildItem 'Cert:\LocalMachine\Root\' | Where-Object Thumbprint -eq '8F43288AD272F3103B6FB1428485EA3014C0BCFE' | select-object @{n="MachineName";e={$computer}},Subject,NotBefore,@{n="ValidDays";e={($_.NotAfter-$_.NotBefore).days}},NotAfter,@{n="DaysToExp";e={($_.NotAfter-(Get-Date)).Days}},Thumbprint,Issuer,@{n="SignatureAlgorithm";e={$_.SignatureAlgorithm.FriendlyName}},@{n="PublicKeySize";e={$_.PublicKey.key.keysize}},@{n="ExtKeyUsage";e={$_.extensions.enhancedkeyusages.friendlyname -join ','}},HasPrivateKey,FriendlyName | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
Get-ChildItem Cert:LocalMachine/My | select-object @{n="MachineName";e={$computer}},Subject,NotBefore,@{n="ValidDays";e={($_.NotAfter-$_.NotBefore).days}},NotAfter,@{n="DaysToExp";e={($_.NotAfter-(Get-Date)).Days}},Thumbprint,Issuer,@{n="SignatureAlgorithm";e={$_.SignatureAlgorithm.FriendlyName}},@{n="PublicKeySize";e={$_.PublicKey.key.keysize}},@{n="ExtKeyUsage";e={$_.extensions.enhancedkeyusages.friendlyname -join ','}},HasPrivateKey,FriendlyName | Where-Object { $_.ValidDays -GT 7 } | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | Select-Object -Skip 1 |foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_AllCertificates>")

<#
{% endif %}

{% if ('Windows_NLB' in check_list or 'all' in check_list) and '-Windows_NLB' not in check_list %}
# Check whether NLB cluster is installed
##########################################################################>
$crt++
Write-Output "$crt. $computer - Check whether NLB cluster is installed"
$file_stream_output.WriteLine("#### <Windows_NLB>")
$file_stream_output.WriteLine("""MachineName"";""NLB Status""")
MsgPrint "info" "info $crt. $computer - Check whether NLB cluster is installed"
Try{
    Get-NlbCluster -ErrorAction silentlycontinue
    $file_stream_output.WriteLine("""$computer"";""NLB Cluster is present""")
}
Catch{
    $file_stream_output.WriteLine("""$computer"";""NLB Cluster not detected.""")
}
$file_stream_output.WriteLine("#### </Windows_NLB>")

<#
{% endif %}

{% if ('Windows_SSL_TLS_State' in check_list or 'all' in check_list) and '-Windows_SSL_TLS_State' not in check_list %}
# SSL & TLS Server check
##########################################################################>
$crt++
Write-Output "$crt. $computer - SSL & TLS Server check"
# https://techcommunity.microsoft.com/t5/IIS-Support-Blog/How-to-disable-SSL-2-0-or-SSL-3-0-from-IIS-Server/ba-p/287812
# https://docs.microsoft.com/en-us/windows-server/security/tls/tls-registry-settings
# https://www.ssllabs.com/projects/documentation/
# https://learn.microsoft.com/en-us/windows/win32/secauthn/protocols-in-tls-ssl--schannel-ssp-
MsgPrint "info" "info $crt. $computer - SSL & TLS Server check"
$file_stream_output.WriteLine("#### <Windows_SSL_TLS_State>")
$file_stream_output.WriteLine("""MachineName"";""Protocol"";""Server-Client"";""SSL_TLS_State"";""RegistryKeyState""")
$sslTable = @()
$sslTable += [PSCustomObject]@{
        "OS" = "2008"
        "SSL20Client" = "Disabled"
        "SSL20Server" = "Enabled"
        "SSL30Client" = "Enabled"
        "SSL30Server" = "Enabled"
        "TLS10Client" = "Enabled"
        "TLS10Server" = "Enabled"
        "TLS11Client" = "Not supported"
        "TLS11Server" = "Not supported"
        "TLS12Client" = "Not supported"
        "TLS12Server" = "Not supported"
        "TLS13Client" = "Not supported"
        "TLS13Server" = "Not supported"
}

$sslTable += [PSCustomObject]@{
        "OS" = "2008 R2"
        "SSL20Client" = "Disabled"
        "SSL20Server" = "Enabled"
        "SSL30Client" = "Enabled"
        "SSL30Server" = "Enabled"
        "TLS10Client" = "Enabled"
        "TLS10Server" = "Enabled"
        "TLS11Client" = "Disabled"
        "TLS11Server" = "Disabled"
        "TLS12Client" = "Disabled"
        "TLS12Server" = "Disabled"
        "TLS13Client" = "Not supported"
        "TLS13Server" = "Not supported"
}
$sslTable += [PSCustomObject]@{
        "OS" = "2012"
        "SSL20Client" = "Disabled"
        "SSL20Server" = "Disabled"
        "SSL30Client" = "Enabled"
        "SSL30Server" = "Enabled"
        "TLS10Client" = "Enabled"
        "TLS10Server" = "Enabled"
        "TLS11Client" = "Enabled"
        "TLS11Server" = "Enabled"
        "TLS12Client" = "Enabled"
        "TLS12Server" = "Enabled"
        "TLS13Client" = "Not supported"
        "TLS13Server" = "Not supported"
}
$sslTable += [PSCustomObject]@{
        "OS" = "2016"
        "SSL20Client" = "Not supported"
        "SSL20Server" = "Not supported"
        "SSL30Client" = "Disabled"
        "SSL30Server" = "Disabled"
        "TLS10Client" = "Enabled"
        "TLS10Server" = "Enabled"
        "TLS11Client" = "Enabled"
        "TLS11Server" = "Enabled"
        "TLS12Client" = "Enabled"
        "TLS12Server" = "Enabled"
        "TLS13Client" = "Not supported"
        "TLS13Server" = "Not supported"
}
$sslTable += [PSCustomObject]@{
        "OS" = "2019"
        "SSL20Client" = "Not supported"
        "SSL20Server" = "Not supported"
        "SSL30Client" = "Disabled"
        "SSL30Server" = "Disabled"
        "TLS10Client" = "Enabled"
        "TLS10Server" = "Enabled"
        "TLS11Client" = "Enabled"
        "TLS11Server" = "Enabled"
        "TLS12Client" = "Enabled"
        "TLS12Server" = "Enabled"
        "TLS13Client" = "Not supported"
        "TLS13Server" = "Not supported"
}
$sslTable += [PSCustomObject]@{
        "OS" = "2022"
        "SSL20Client" = "Not supported"
        "SSL20Server" = "Not supported"
        "SSL30Client" = "Disabled"
        "SSL30Server" = "Disabled"
        "TLS10Client" = "Enabled"
        "TLS10Server" = "Enabled"
        "TLS11Client" = "Enabled"
        "TLS11Server" = "Enabled"
        "TLS12Client" = "Enabled"
        "TLS12Server" = "Enabled"
        "TLS13Client" = "Enabled"
        "TLS13Server" = "Enabled"
}

$defaults = $sslTable | Where-Object -filterscript { ($computerOS.Caption).Contains($_.OS) }
$pattern = '[^a-zA-Z0-9]'
$SSLTLSState = @()
$ProtocolList       = @("SSL 2.0","SSL 3.0","TLS 1.0","TLS 1.1","TLS 1.2","TLS 1.3")
$ProtocolSubKeyList = @("Client","Server")
$RegistryPath = "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\"
ForEach ($Protocol in $ProtocolList){
    ForEach ($Key in $ProtocolSubKeyList) {
    $CurrentRegPath = $RegistryPath + $Protocol + "\" + $key
    $DisabledByDefaultValue = "none"
    $EnabledValue = "none"
    $def = ($Protocol -replace $pattern,'')+$key
    $status = $defaults.$def
    if (Test-Path $currentRegPath) {
        If ((Get-ItemProperty $currentRegPath).PSObject.Properties.Name -contains "Enabled") {
            $EnabledValue = Get-ItemProperty -Path $currentRegPath -Name "Enabled" | Select-Object "Enabled" -ExpandProperty "Enabled"
        }
        Else { $EnabledValue = "none" }
        If ((Get-ItemProperty $currentRegPath).PSObject.Properties.Name -contains "DisabledByDefault") {
            $DisabledByDefaultValue = Get-ItemProperty -Path $currentRegPath -Name "DisabledByDefault" | Select-Object "DisabledByDefault" -ExpandProperty "DisabledByDefault"
        }
        Else { $DisabledByDefaultValue = "none" }
        $messg = "[$CurrentRegPath] exist with Enabled = $EnabledValue and DisabledByDefault = $DisabledByDefaultValue"
    }
    else {
        $messg = "[$CurrentRegPath] does not exist"
        }
    switch ($status) {
    "Not supported" {
                $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Disabled"";""$messg, the protocol is not supported"""
        }
    "Enabled" {
            If (($EnabledValue -eq "none") -and ($DisabledByDefaultValue -eq "none")) {
                $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Enabled"";""$messg, the protocol is enabled by default"""
                }
            else {
                If (($EnabledValue -eq 1) -and ($DisabledByDefaultValue -eq 0)){
                    $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Enabled"";""$messg, the protocol is enabled by key"""
                    }
                    else {
                        If (($EnabledValue -eq 0) -and ($DisabledByDefaultValue -eq 1)) {
                            $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Disabled"";""$messg, the protocol is disabled by key"""
                            }
                        else {
                            $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Incorrect configuration"";""$messg"""
                        }
                    }
            }
        }
    "Disabled" {
            If (($EnabledValue -eq "none") -and ($DisabledByDefaultValue -eq "none")) {
                $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Disabled"";""$messg, the protocol is disabled by default"""
                }
            else {
                If (($EnabledValue -eq 1) -and ($DisabledByDefaultValue -eq 0)){
                    $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Enabled"";""$messg, the protocol is enabled by key"""
                    }
                    else {
                        If (($EnabledValue -eq 0) -and ($DisabledByDefaultValue -eq 1)) {
                            $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Disabled"";""$messg, the protocol is disabled by key"""
                            }
                        else {
                            $SSLTLSState += """$computer"";""$Protocol"";""$key"";""Incorrect configuration"";""$messg"""
                        }
                    }
            }
        }
    } #end switch
   } #End ForEach Client/Server
}#End ForEach Protocol
$SSLTLSState | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_SSL_TLS_State>")
<#
{% endif %}

{% if ('Windows_ScheduledTasks' in check_list or 'all' in check_list) and '-Windows_ScheduledTasks' not in check_list %}
# Scheduled Tasks
##########################################################################>
$crt++
Write-Output "$crt. $computer - Scheduled Tasks"
MsgPrint "info" "info $crt. $computer - Scheduled Tasks"
$file_stream_output.WriteLine("#### <Windows_ScheduledTasks>")
try {
    schtasks /query /v /fo csv | ConvertFrom-CSV | Where-Object {$_.TaskName -notcontains "TaskName" -and $_.Status -notlike 'Disabled' -and $_.Status -notlike '' -and $_.'Task To Run' -notmatch 'COM handler'} | Export-Csv -Delimiter ";" -NoTypeInformation -Encoding UTF8 -Path $logdir\$crt-Scheduled_Tasks.csv
}
catch {
    MsgPrint "error" "error $crt. $computer - schtasks command failed"
}
Try {
    Get-Content $logdir\$crt-Scheduled_Tasks.csv | foreach-object {$file_stream_output.WriteLine($_)}
}
catch {
    MsgPrint "error" "error $crt. $computer - Retrieving Scheduled Tasks"
}
$file_stream_output.WriteLine("#### </Windows_ScheduledTasks>")


# Create list with paths and executables from "task to run" in Scheduled Tasks for acl
######################################################################################
msgprint "info" "info $crt. $computer - Create list with paths and executables from Task_To_Run in Scheduled Tasks for acl"
$listtasks = import-csv -Path "$logdir\$crt-Scheduled_Tasks.csv" -Delimiter ";" | Select-Object 'Task To Run'
$list_as_string = @()
$i = 0
try {
    do {
        if ($listtasks[$i].'Task to Run' -match  "^.+?\.(BAT|BIN|CMD|COM|CPL|EXE|INS|INX|ISU|JOB|JSE|LNK|MSC|MSI|MSP|MST|PAF|PIF|PS1|REG|RGS|SCR|SCT|SHB|SHS|U3P|VBE|VBS|VBSCRIPT|WS|WSF|WSH)") {
            $str_cmd = $matches[0]
        }
        else {
            $str_cmd = ""
        }
        $str = [Environment]::ExpandEnvironmentVariables($str_cmd)
        $str = $str -replace '["]',""
        $list_as_string += $str
        do
          {
              $str = split-path $str
              $list_as_string += $str
          }
          while ($str -ne "")
        $i = $i + 1
        }
        while ($null -ne $listtasks[$i])
}
catch {
    MsgPrint "error" "error $crt. $computer - Error creating commands from 'Task to Run'"
}
$aclitems = $list_as_string.Where({ $_ -ne "" }) | Sort-Object -Unique
$aclitems | Out-file -append -FilePath $logdir\$crt-Scheduled_Tasks.csv
$newaclitems = $aclitems | Where-Object { $_ -ne ((Get-ChildItem Env:SystemDrive).Value+"\") }

# Extract "acl data  for scheduled tasks"
##########################################################################

msgprint "info" "info $crt. $computer - Extracting ACL data for scheduled tasks"
$file_stream_output.WriteLine("#### <Windows_acl_schdtasks>")

#$PrivAccounts = @('Administrators','Domain Admins','Enterprise Admins','Power Users','Backup Operators','Print Operators','Network Configuration Operators','DHCP Administrators','Account Operators','Server Operators','Group Policy Creator Owners','Schema Admins','Group Policy Owners','Enterprise Operators','Certificate Service DCOM Access','Distributed COM Users','Event Log Readers','Performance Log Users','Performance Monitor Users','Eventlog','All Application Packages','TrustedInstaller','Local Service','EventLog','Creator Owner','System','All Restricted Application Packages')
$PrivAccounts = @('Administrators','Domain Admins','Enterprise Admins','Backup Operators','Print Operators','Network Configuration Operators','DHCP Administrators','Account Operators','Server Operators','Group Policy Creator Owners','Schema Admins','Certificate Service DCOM Access','Distributed COM Users','Event Log Readers','Performance Log Users','Performance Monitor Users','Eventlog','All Application Packages','TrustedInstaller','Local Service','EventLog','Creator Owner','System','All Restricted Application Packages','Access Control Assistance Operators','Allowed RODC Password Replication','Cert Publishers','Cryptographic Operators','DnsAdmins','Enterprise Key Admins','Hyper-V Administrators','IIS_IUSRS','Incoming Forest Trust Builders','Key Admins','Pre-Windows 2000 Compatible Access','Protected Users','Remote Desktop Users','Remote Management Users','Storage Replica Administrators','Windows Authorization Access group')
$aclarray = @()
ForEach ($item in $newaclitems) {
    $acl = $null
    if (Test-Path $item -isvalid) {
        if (Test-Path $item) {
            $acllist = get-acl $item | Select-Object -ExpandProperty Access
        }
        else {
            msgprint "warning" "warning $crt. $computer - Testing KO path $item"
        }
    }
    else {
        msgprint "error" "error $crt. $computer - Extracting ACL data - invalid path $item"
    }
	ForEach ($acl in $acllist) {
	    If ([string]($acl.IdentityReference) -Like "*\*") {
             $null,$CurrentID = ([string]($acl.IdentityReference)).Split("\")
             }
        Else {
             $CurrentID = [string]($acl.IdentityReference)
        }
		# Skip the ACL if user in the "PrivAccounts" list
		If (-Not($PrivAccounts -Contains $CurrentID))  {
	        $obj = New-Object -TypeName PSobject
            $obj | Add-Member -MemberType NoteProperty -Name "MachineName" -Value $computer
            $obj | Add-Member -MemberType NoteProperty -Name "Path" -Value $item
	        $obj | Add-Member -MemberType NoteProperty -Name "FileSystemRights" -Value $acl.FileSystemRights
            $obj | Add-Member -MemberType NoteProperty -Name "AccessControlType" -Value $acl.AccessControlType
	        $obj | Add-Member -MemberType NoteProperty -Name "IdentityReference" -Value $acl.IdentityReference
	        $obj | Add-Member -MemberType NoteProperty -Name "IsInherited" -Value $acl.IsInherited
	        $obj | Add-Member -MemberType NoteProperty -Name "InheritanceFlags" -Value $acl.InheritanceFlags
	        $obj | Add-Member -MemberType NoteProperty -Name "PropagationFlags" -Value $acl.PropagationFlags
			$aclarray += $obj
		}
	}
}

$aclarray | convertto-csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_acl_schdtasks>")


<#
{% endif %}

{% if ('Windows_Powerplan' in check_list or 'all' in check_list) and '-Windows_Powerplan' not in check_list %}
# Power plan active
##########################################################################>
$crt++
Write-Output "$crt. $computer - Power plan"
MsgPrint "info" "info $crt. $computer - Power plan"
$file_stream_output.WriteLine("#### <Windows_Powerplan>")
$file_stream_output.WriteLine("""MachineName"";""PowerPlan""")
try{
    $PowerPlan = Get-CimInstance -Class win32_powerplan -Namespace root\cimv2\power |
Where-Object {$_.IsActive -eq "true"} | Select-Object ElementName -ExpandProperty ElementName
    $file_stream_output.WriteLine("""$computer"";""$PowerPlan""")
}
catch{
    MsgPrint "error" "error $crt. $computer - Power plan gather date failed"
}
$file_stream_output.WriteLine("#### </Windows_Powerplan>")

<#
{% endif %}

{% if ('Windows_GPResult' in check_list) and '-Windows_GPResult' not in check_list %}
# Group Policy result
# commented for time being until policies will be crafted
##########################################################################>
$crt++
Write-Output "$crt. $computer - Group Policy result"
MsgPrint "info" "info $crt. $computer - Group Policy result"
$file_stream_output.WriteLine("#### <Windows_GPResult>")
gpresult /h $logdir\$crt-GPresult.html
$file_stream_output.WriteLine("#### </Windows_GPResult>")

<#
{% endif %}

{% if ('Windows_Uptime' in check_list or 'all' in check_list) and '-Windows_Uptime' not in check_list %}
# Uptime
##########################################################################>
$crt++
Write-Output "$crt. $computer - Uptime"
MsgPrint "info" "info $crt. $computer - Uptime"
$file_stream_output.WriteLine("#### <Windows_Uptime>")
$file_stream_output.WriteLine("""MachineName"";""lastBootTime"";""days""")
try {
    $LastBootTime = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
    $DaysSinceReboot = (New-TimeSpan -Start $lastBootTime -End (Get-Date)).Days
    $file_stream_output.WriteLine("""$computer"";""$LastBootTime"";""$DaysSinceReboot""")
}
catch{
    MsgPrint "error" "error $crt. $computer - Uptime"
}
$file_stream_output.WriteLine("#### </Windows_Uptime>")

<#
{% endif %}

{% if ('Windows_Time' in check_list or 'all' in check_list) and '-Windows_Time' not in check_list %}
# Time: Verify Windows Time services best practice
#########################################################################>
<# https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-computersystem
https://social.technet.microsoft.com/wiki/contents/articles/50924.active-directory-time-synchronization.aspx
https://adamtheautomator.com/pending-reboot-registry/
##########################################################################
0x01 - use special poll interval SpecialInterval
0x02 - UseAsFallbackOnly
0x04 - send request as SymmetricActive mode
0x08 - send request as Client mode
0x05 - system is configured to sync with an external time source.
0XA  - system will not sync with any external time source but would sync with itself.

Use case:
Standalone Workstation    (0)
Member Workstation        (1)
Standalone Server         (2)
Member Server             (3)
Backup Domain Controller  (4)
Primary Domain Controller (5)
##########################################################################>
$crt++
Write-Output "$crt. $computer - Time: Verify Windows Time service best practice"
MsgPrint "info" "info $crt. $computer - Time: Verify Windows Time service best practice"
$file_stream_output.WriteLine("#### <Windows_Time>")
$file_stream_output.WriteLine("""MachineName"";""ServerRole"";""W32TimeService"";""NTPserverType"";""NTPServerConfig"";""BestPractice""")
try{
    $computerSystem = Get-CimInstance Win32_ComputerSystem
    $DomainRole = ("Standalone Workstation","Member Workstation","Standalone Server","Member Server","Backup Domain Controller","Primary Domain Controller")
    $serverRoleString = $DomainRole[$computerSystem.DomainRole]
    $serverRole = $computerSystem.DomainRole
    $BestPractice = "Unknown"
    $ServiceStatus = [string](Get-Service -Name W32Time -ErrorAction Stop).Status
    $NTPserverType = Get-RegKey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\W32time\Parameters:Type"
    if ($NTPserverType -eq "registry key not found" ) {
        $NTPserverType = Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\Parameters:Type"
    }
    # Using w32tm cmd instead of registry for better accuracy
    $NTPserverConfig = & 'w32tm' '/query', '/source'
    if ($NTPserverType -eq "NoSync"){
        $BestPractice = "False"
    }

    if ($NTPserverType -eq "AllSync"){
        # PDC
        if ($serverRole -eq 5){
            $BestPractice = "False"
        }
        else{
            # Standalone server or workstation not PDC
            if ($serverRole -eq 0 -or $serverRole -eq 2){
                # Check NTP Server config
                if ($null -eq $NTPserverConfig){
                    $BestPractice = "False"
                }
                else{
                    $BestPractice = "True"
                }
            }
            else{
                $BestPractice = "True"
            }
        }
    }
    if ($NTPserverType -eq "NTP"){
        # Standalone workstation, standalone server or PDC
        if ($serverRole -eq 2 -or $serverRole -eq 0 -or $serverRole -eq 5){
            if ($null -eq $NTPserverConfig){
                $BestPractice = "False"
            }
            else{
                $BestPractice = "True"
            }
        }
        else{
            # Domain Member server or workstation
            $BestPractice = "False"
        }
    }
    if ($NTPserverType -eq "NT5DS"){
        # Domain Member server or workstation or backup domain controller
        if ($serverRole -eq 1 -or $serverRole -eq 3 -or $serverRole -eq 4){
            $BestPractice = "True"
        }
        else{
            $BestPractice = "False"
        }
    }
    if ($ServiceStatus -ne "Running") {
        $BestPractice = "False"
    }
    $file_stream_output.WriteLine("""$computer"";""$serverRoleString"";""$ServiceStatus"";""$NTPserverType"";""$NTPserverConfig"";""$BestPractice""")
}
catch{
    MsgPrint "error" "error $crt. $computer - Time: Verify Windows Time service best practise"
}
$file_stream_output.WriteLine("#### </Windows_Time>")

<#
{% endif %}

{% if ('Windows_Lcl_Users' in check_list or 'all' in check_list) and '-Windows_Lcl_Users' not in check_list %}
# Windows Local users
##########################################################################>
$crt++
Write-Output "$crt. $computer - Windows Local users"
MsgPrint "info" "info $crt. $computer - Windows Local users"
$file_stream_output.WriteLine("#### <Windows_Lcl_Users>")
$file_stream_output.WriteLine("""MachineName"";""Domain_Role"";""Group"";""UserName"";""Disabled"";""Password_Last_Time_Set"";""SID"";""Days"";""UID_Label"";""Password Expires""")
try {
    $computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem
    $DomainName = $computerSystem.Domain
    $DomainRole = ("Standalone Workstation","Member Workstation","Standalone Server","Member Server","Backup Domain Controller","Primary Domain Controller")
    $serverRoleString = $DomainRole[$computerSystem.DomainRole]
    $localUsers = Get-CimInstance -Class Win32_UserAccount -Filter "LocalAccount=True" | Select-Object name,sid,disabled,description,passwordexpires
    if ($SystemInfo.Roles -like "*Domain_Controller*"){
        $Role = "Domain Controller"
        $group=$user=$disabled=$LastPassword=$SID=$days=$gecos=$passexp="Not Applicable"
        $file_stream_output.WriteLine("""$computer"";""$serverRoleString"";""$group"";""$user"";""$disabled"";""$LastPassword"";""$SID"";""$days"";""$gecos"";""$passexp""")
    }else{
        $comp =[ADSI]"WinNT://$($env:COMPUTERNAME)"
        $groups = $comp.psbase.children | where { $_.psbase.schemaClassName -eq 'group' }
        foreach ($group in $groups.name) {
            $groupObj =[ADSI]"WinNT://./$group,group"
            $membersObj = @($groupObj.psbase.Invoke("Members"))
            $members = ($membersObj | ForEach-Object {$_.GetType().InvokeMember("Name", 'GetProperty', $null, $_, $null)})
            ForEach ($item in $localUsers){
                $disabled = $item.disabled
                $user = $item.name
                $SID = $item.sid
                $gecos = $item.description
                $passexp = $item.passwordexpires
                If ($members -contains $user){
                try {
                    if (($PSVersionTable.PSVersion.Major+$PSVersionTable.PSVersion.Minor/10) -lt 5.1) {
                        if ($Role -ne "Domain Controller") {
                            $LastPassword = (net user $user) | select-string -pattern '^Password\slast\sset\s+(\d+.+$)' | %{$_.Matches.Groups[1].value}
                        }
                        #MsgPrint "error" "error $crt. $computer - Local users $group : Powershell version too low"
                    }
                    Else{
                        $LastPassword = (Get-LocalUser $user).PasswordLastSet
                    }
                    try {
                        $days = (New-TimeSpan -Start $LastPassword -End $(get-date)).Days
                    }
                    catch {
                        MsgPrint "error" "error $crt. $computer - Local users $group : Cannot calculate days since last set because $($error[0].Exception)"
                        $days = ""
                    }
                    $file_stream_output.WriteLine("""$computer"";""$serverRoleString"";""$group"";""$user"";""$disabled"";""$LastPassword"";""$SID"";""$days"";""$gecos"";""$passexp""")
                }
                catch {
                    MsgPrint "error" "error $crt. $computer - Local users $group : Unable to get LastPasswordSet because $($error[0].Exception)"
                }
                }
                Else{
                    #User does not exist in group
                }
            }
        }
    }

}
catch{
    MsgPrint "error" "error $crt. $computer - Windows Local users $($Error[0].Exception)"
}
$file_stream_output.WriteLine("#### </Windows_Lcl_Users>")

<#
{% endif %}

{% if ('Windows_lclgrp' in check_list or 'all' in check_list) and '-Windows_lclgrp' not in check_list %}
# Windows local groups
##########################################################################>

# Server role

$computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem
$DomainName = $computerSystem.Domain
$DomainRole = ("Standalone Workstation","Member Workstation","Standalone Server","Member Server","Backup Domain Controller","Primary Domain Controller")
$serverRoleString = $DomainRole[$computerSystem.DomainRole]

$crt++
Write-Output "$crt. $computer - Windows local groups"
MsgPrint "info" "info $crt. $computer - Windows local groups"
$file_stream_output.WriteLine("#### <Windows_lclgrp>")
if ($serverRoleString -in @("Primary Domain Controller","Backup Domain Controller")) {
    MsgPrint "info" "info $crt. $computer - Domain controller: no Windows local groups"
}
else {
    try {
        $grps = get-localgroup
        $usrs = $null
        $out = @()
        foreach ($grp in $grps) {
            try {
                $usrs = get-localgroupmember -group $grp -ErrorAction Stop
            }
            catch {
                MsgPrint "error" "error $crt. $computer - Windows local groups $($Error[0].tostring())"
            }
            if ($usrs -ne $null) {
                $out += $usrs | Select @{N='MachineName';E={$computer}},@{N='GroupName';E={$grp.name}},@{N='GroupUID';E={$grp.description}},name,objectclass,principalsource
            }
        }
        $out | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
    }
    catch {
        MsgPrint "error" "error $crt. $computer - Windows local groups"
    }
}
$file_stream_output.WriteLine("#### </Windows_lclgrp>")
<#
{% endif %}

{% if ('Windows_Defender' in check_list or 'all' in check_list) and '-Windows_Defender' not in check_list %}
# Antivirus (Windows Defender) installed?
##########################################################################>
$crt++
Write-Output "$crt. $computer - Windows Defender Antivirus"
MsgPrint "info" "info $crt. $computer - Windows Defender Antivirus"
$file_stream_output.WriteLine("#### <Windows_Defender>")
try {
    $defender_service_status = (Get-Service windefend -ErrorAction Stop).status
}
catch {
    MsgPrint "Error" "error $crt. $computer - Windows Defender Service - $($Error[0].tostring())"
    $defender_service_status = "None"
}
If ($defender_service_status -eq "Running") {
    try {
        $Defender = Get-MpComputerStatus
        $Defender | Select-Object @{N="MachineName";E = {$computer}},AntispywareEnabled, AntispywareSignatureAge, AntispywareSignatureLastUpdate, AntispywareSignatureVersion,AntivirusEnabled, AntivirusSignatureAge, AntivirusSignatureLastUpdated,AntivirusSignatureVersion, BehaviorMonitorEnabled, IoavProtectionEnabled,IsTamperProtected, IsVirtualMachine, LastFullScanSource, LastQuickScanSource, NISEnabled,NISEngineVersion, NISSignatureAge, NISSignatureLastUpdated, NISSignatureVersion, OnAccessProtectionEnabled, PSComputerName, QuickScanAge, QuickScanEndTime, QuickScanStartTime,RealTimeProtectionEnabled, RealTimeScanDirection, TamperProtectionSource |
        ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
    }
    catch {
        MsgPrint "Error" "error $crt. $computer - Windows Defender Feature - $($Error[0].tostring())"
        $file_stream_output.WriteLine("""MachineName"";""AntispywareEnabled""")
        $file_stream_output.WriteLine("""$computer"";""Defender not OK (or OS older than Server 2016)""")
    }
}
else {
    $file_stream_output.WriteLine("""MachineName"";""AntispywareEnabled""")
    $file_stream_output.WriteLine("""$computer"";""WinDefend service not existing or not running""")
}
$file_stream_output.WriteLine("#### </Windows_Defender>")

<#
{% endif %}

{% if ('Windows_CarbonBlack' in check_list or 'all' in check_list) and '-Windows_CarbonBlack' not in check_list %}
# EDR (Endpoint detection and response) Carbon black
##########################################################################>
$crt++
Write-Output "$crt. $computer - EDR (Endpoint detection and response) - Carbon Black"
MsgPrint "info" "info $crt. $computer - EDR (Endpoint detection and response) - Carbon Black"
$file_stream_output.WriteLine("#### <Windows_CarbonBlack>")
$file_stream_output.WriteLine("""MachineName"";""Message""")
Try {
    $CarbonBlack = "HKLM:\Software\CarbonBlack\config"
    $CarbonBlackpath = test-path $CarbonBlack
    If ($CarbonBlackpath -eq $True){
            $CarbonBlackSensorID = Get-RegKey "HKEY_LOCAL_MACHINE\Software\CarbonBlack\config:SensorId"
            if ($CarbonBlackSensorID -eq "registry key not found" -or $CarbonBlackSensorID -eq "key extract failed"){
                #CarbonBlackSensorID empty or cannot be retrieved
                $file_stream_output.WriteLine("""$computer"";""Empty""")
            }
            Else{
                #CarbonBlackSensorID is OK
                $file_stream_output.WriteLine("""$computer"";""OK""")
            }
        }
    Else{
        # Carbon Black is not installed
        $file_stream_output.WriteLine("""$computer"";""Not installed""")
    }
}
catch {
    MsgPrint "error" "error $crt. $computer - EDR (Endpoint detection and response) - Carbon Black"
}
$file_stream_output.WriteLine("#### </Windows_CarbonBlack>")

<#
{% endif %}

{% if ('Windows_Cortex' in check_list or 'all' in check_list) and '-Windows_Cortex' not in check_list %}
# EDR (Endpoint detection and response) Cortex
##########################################################################>
$crt++
Write-Output "$crt. $computer - EDR (Endpoint detection and response) - Cortex"
MsgPrint "info" "info $crt. $computer - EDR (Endpoint detection and response) - Cortex"
$file_stream_output.WriteLine("#### <Windows_Cortex>")
$file_stream_output.WriteLine("""MachineName"";""Message""")
$cortex = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Cortex*"}
if($null -ne $cortex){
    #Cortex is installed
    $file_stream_output.WriteLine("""$computer"";""Installed""")
}
Else{
    #Cortex is not installed
    $file_stream_output.WriteLine("""$computer"";""Not installed""")
}
$file_stream_output.WriteLine("#### </Windows_Cortex>")

<#
{% endif %}

{% if ('Windows_User_Profiles' in check_list or 'all' in check_list) and '-Windows_User_Profiles' not in check_list %}
# User profiles status
##########################################################################>
$crt++
Write-Output "$crt. $computer - User profiles status"
MsgPrint "info" "info $crt. $computer - User profiles status"

$file_stream_output.WriteLine("#### <Windows_User_Profiles>")
$Profiles = Get-CimInstance -Class Win32_UserProfile -ErrorAction 0
$Out = @()
ForEach ($profile in $profiles) {
    try {
        $objSID = New-Object System.Security.Principal.SecurityIdentifier($profile.sid)
        $objuser = $objsid.Translate([System.Security.Principal.NTAccount])
        $objusername = $objuser.value
        $oun = ($objusername -split '\\',2)[1]
        $lpath = $profile.localpath -replace $oun,$profile.sid
    }
    catch {
        $objusername = $profile.sid
        $lpath = $profile.localpath
    }
    switch($profile.status){
        1 { $profileType="Temporary" }
        2 { $profileType="Roaming" }
        4 { $profileType="Mandatory" }
        8 { $profileType="Corrupted" }
        default { $profileType = "LOCAL" }
    }
    $User = $objUser.Value

    $Out += [pscustomobject]@{
        "MachineName" = $computer
        "ProfileName" = $profile.sid
        "ProfilePath" = $lpath
        "ProfileType" = $ProfileType
        "IsinUse" = $profile.loaded
        "IsSystemAccount" = $profile.special
    }
}
$Out | ConvertTo-Csv -Delimiter ';' -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_User_Profiles>")

<#
{% endif %}

{% if ('Windows_LM_Hash' in check_list or 'all' in check_list) and '-Windows_LM_Hash' not in check_list %}
# Check if enabled storing an LM hash of your password
##########################################################################
# https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/prevent-windows-store-lm-hash-password #>
$crt++
Write-Output "$crt. $computer - LM Hash check"
MsgPrint "info" "info $crt. $computer - LM Hash check"
$file_stream_output.WriteLine("#### <Windows_LM_Hash>")
$file_stream_output.WriteLine( """MachineName"";""Message"";""KeyValue""")
try{
    # Test if registry key with DWORD "NoLmHash" exists and what is its value
    $LMHash = Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:NoLmHash"
    if ($LMHash -eq "1"){
        #Write "LM Hash is Disabled. OK"
        $file_stream_output.WriteLine("""$computer"";""OK"";""$LMHash""")
    } else {
        #LM Hash is enabled by default (key not present) or explicit enabled  key exists with value zero
        $file_stream_output.WriteLine("""$computer"";""Fail"";""$LMHash""")
    }
}
catch{
    #LM Hash could not be retrieved
    $file_stream_output.WriteLine("""$computer"";""Fail"";""$LMHash""")
}
$file_stream_output.WriteLine("#### </Windows_LM_Hash>")

<#
{% endif %}

{% if ('Windows_Logons_Cache' in check_list or 'all' in check_list) and '-Windows_Logons_Cache' not in check_list %}
# Number of previous logons to cache
##########################################################################
# https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/interactive-logon-number-of-previous-logons-to-cache-in-case-domain-controller-is-not-available #>
# Possible values for Role:
# Standalone Workstation (0)
# Member Workstation (1)
# Standalone Server (2)
# Member Server (3)
# Backup Domain Controller (4)
# Primary Domain Controller (5)
$crt++
$Role = (Get-CimInstance -Class Win32_ComputerSystem).DomainRole
$CLC = $null
Write-Output "$crt. $computer - Number of previous logons to cache"
MsgPrint "info" "info $crt. $computer - Number of previous logons to cache"
$file_stream_output.WriteLine("#### <Windows_Logons_Cache>")
$file_stream_output.WriteLine("""MachineName"";""Message"";""KeyValue""")
try{
    # Test if registry key with Reg_SZ "CachedLogonsCount" exists and what is its value
    $CLC = Get-RegKey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:CachedLogonsCount"
    if (($role -ne 1) -and ($role -ne 3)) {
    # CachedLogonsCount is valid only for servers and workstations joined to Active Directory and which are not domain controllers
        $file_stream_output.WriteLine("""$computer"";""OK"";""$CLC""")
    }
    else {
        if (("0","registry key not found","registry key empty","key extract failed").Contains($CLC)){
            # CachedLogonsCount key not present, or empty or zero. OK
            $file_stream_output.WriteLine("""$computer"";""OK"";""$CLC""")
        }
        else {
            # CachedLogonsCount key present different from zero. NOK
            $file_stream_output.WriteLine("""$computer"";""Fail"";""$CLC""")
        }
    }
}
catch{
    # Error on getting CachedLogonsCount key. NOK
    $file_stream_output.WriteLine("""$computer"";""Fail"";""$CLC""")
}
$file_stream_output.WriteLine("#### </Windows_Logons_Cache>")

<#
{% endif %}

{% if ('Windows_LocalAccountTokenFilter' in check_list or 'all' in check_list) and '-Windows_LocalAccountTokenFilter' not in check_list %}
# Status of LocalAccountTokenFilterPolicy
##########################################################################
# https://www.stigviewer.com/stig/windows_server_2008_r2_member_server/2014-04-02/finding/V-36439 #>
# Possible values for DomainRole:
# Standalone Workstation (0)
# Member Workstation (1)
# Standalone Server (2)
# Member Server (3)
# Backup Domain Controller (4)
# Primary Domain Controller (5)
$crt++
Write-Output "$crt. $computer - Status of LocalAccountTokenFilterPolicy"
MsgPrint "info" "info $crt. $computer - Status of LocalAccountTokenFilterPolicy"
$file_stream_output.WriteLine("#### <Windows_LocalAccountTokenFilter>")
$file_stream_output.WriteLine("""MachineName"";""Message"";""KeyValue""")
$LATF = $null
try{
    # Test if member server or standalone
    if ((Get-CimInstance -Class Win32_ComputerSystem).domainrole -ge 3) {
        # Test if registry key with Reg_SZ "LocalAccountTokenFilterPolicy" exists and what is its value
        $LATF = Get-RegKey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:LocalAccountTokenFilterPolicy"
        if ($LATF -eq "1"){
            # LocalAccountTokenFilterPolicy key is present, and is 1. NOK
            $file_stream_output.WriteLine("""$computer"";""Fail"";""$LATF""")
        }
        else {
            $file_stream_output.WriteLine("""$computer"";""OK"";""$LATF""")
        }
    }
    else {
        # Server is not join to domain or is workstation. The presence of the key does not matter
        $file_stream_output.WriteLine("""$computer"";""OK"";""$LATF""")
    }
}
catch{
    #Error in getting registry key LocalAccountTokenFilterPolicy
    $file_stream_output.WriteLine("""$computer"";""Fail"";""$LATF""")
}
$file_stream_output.WriteLine("#### </Windows_LocalAccountTokenFilter>")

<#
{% endif %}

{% if ('Windows_EventLogs_Policy' in check_list or 'all' in check_list) and '-Windows_EventLogs_Policy' not in check_list %}
# Eventlogs policy
##########################################################################
# https://docs.microsoft.com/en-us/windows/win32/eventlog/eventlog-key #>
$crt++
$out = @()
Write-Output "$crt. $computer - Eventlogs policy"
MsgPrint "info" "info $crt. $computer - Eventlogs policy"
$file_stream_output.WriteLine("#### <Windows_EventLogs_Policy>")
try {
    $Sources = Get-CimInstance -ClassName Win32_NTEventlogFile
    $out=@()
    ForEach ($source in $Sources) {
            $tinfo = (Get-Culture).TextInfo
            $logprop = wevtutil get-log $source.logfilename
            $out += [PSCustomObject]@{
                "MachineName" = $Env:Computername
                "Log_Name" = $source.logfilename
                "Log_Enabled" = $tinfo.ToTitleCase((($logprop -match 'enabled') -split ": ")[1])
                "Log_NumberOfRecords" = $source.NumberOfRecords
                "Log_MaxSize" = (($logprop -match 'maxSize') -split ": ")[1]
                "Log_Retention" = $tinfo.ToTitleCase((($logprop -match 'retention') -split ": ")[1])
                "Log_AutoBackup" = $tinfo.ToTitleCase((($logprop -match 'autoBackup') -split ": ")[1])
            }
    }
    $out | convertto-csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch {
   $file_stream_output.WriteLine("""$computer"";""Failed to get log properties""")
   MsgPrint "error" "error $crt. $computer - Eventlogs policy. Failed to get log properties"
}
$file_stream_output.WriteLine("#### </Windows_EventLogs_Policy>")

<#
{% endif %}

{% if ('Windows_Multipath-IO' in check_list or 'all' in check_list) and '-Windows_Multipath-IO' not in check_list %}
# Multipath
##########################################################################>


$logging += @([pscustomobject]@{web=$web.Name;format=$logEnabled.logFormat;enabled=$logEnabled.enabled;logging=$logEnabled.logExtFileFlags})



$crt++
Write-Output "$crt. $computer - Check if Multipath-IO feature is installed"
MsgPrint "info" "info $crt. $computer - Check if Multipath-IO feature is installed"
$out = @()
$file_stream_output.WriteLine("#### <Windows_Multipath-IO>")
try{
    Import-Module ServerManager
    $MPIOInst = Get-WindowsFeature *multipath*
    if ($MPIOInst.Installed -eq $True) {
        $MPIOSettings = Get-MPIOSetting
    }
    $Out += [pscustomobject]@{
        "MachineName"=$computer
        "Multipath" = $MPIOInst.Installed
        "PathVerificationState" = $MPIOSettings.PathVerificationState
        "PathVerificationPeriod" = $MPIOSettings.PathVerificationPeriod
        "PDORemovePeriod" = $MPIOSettings.PDORemovePeriod
        "RetryCount" = $MPIOSettings.RetryCount
        "RetryInterval" = $MPIOSettings.RetryInterval
        "UseCustomPathRecoveryTime" = $MPIOSettings.UseCustomPathRecoveryTime
        "CustomPathRecoveryTime" = $MPIOSettings.CustomPathRecoveryTime
        "DiskTimeoutValue" = $MPIOSettings.DiskTimeoutValue
    }
    $Out | ConvertTo-Csv -Delimiter ';' -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch{
    $file_stream_output.WriteLine("""$computer"";""Error"";"""";"""";"""";"""";"""";"""";""")
    MsgPrint "error" "error $crt. $computer - Check Multipath-IO feature"
}
$file_stream_output.WriteLine("#### </Windows_Multipath-IO>")

<#
{% endif %}

{% if ('Windows_NIC-Teaming' in check_list or 'all' in check_list) and '-Windows_NIC-Teaming' not in check_list %}
# NIC Teaming
##########################################################################>
$crt++
Write-Output "$crt. $computer - Check NIC teaming"
MsgPrint "info" "info $crt. $computer - Check NIC teaming"
$file_stream_output.WriteLine("#### <Windows_NIC-Teaming>")
$out = @()
$out += [pscustomobject]@{
        "MachineName" = $computer
        "Name" = "No NIC teaming"
        "Members" = ""
        "TeamNics" = ""
        "TeamingMode" = ""
        "LoadBalancingAlgorithm" = ""
        "Status" = ""
    }
try {
    Import-Module ServerManager
    $NICTSettings = Get-NetLbfoTeam
    if ($null -ne $NICTSettings) {
        $Out.Name = $NICTSettings.Name
        $Out.Members = $NICTSettings.Members
        $Out.TeamNics = $NICTSettings.TeamNics
        $Out.TeamingMode = $NICTSettings.TeamingMode
        $Out.LoadBalancingAlgorithm = $NICTSettings.LoadBalancingAlgorithm
        $Out.Status = $NICTSettings.Status
    }
    $Out | ConvertTo-Csv -delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch {
    if ($os -like "*2008*"){
        $file_stream_output.WriteLine("Error - not supported by Windows Server 2008")
    }
    Else{
        $file_stream_output.WriteLine("Error: $_")
    }
}
$file_stream_output.WriteLine("#### </Windows_NIC-Teaming>")

<#
{% endif %}

{% if ('Windows_CrashDump' in check_list or 'all' in check_list) and '-Windows_CrashDump' not in check_list %}
# Crash Dump Configuration
##########################################################################>
# https://docs.microsoft.com/en-us/troubleshoot/windows-server/performance/memory-dump-file-options
# CrashDumpEnabled REG_DWORD 0x0 = None
# CrashDumpEnabled REG_DWORD 0x1 = Complete memory dump
# CrashDumpEnabled REG_DWORD 0x2 = Kernel memory dump
# CrashDumpEnabled REG_DWORD 0x3 = Small memory dump (64 KB)
# CrashDumpEnabled REG_DWORD 0x7 = Automatic memory dump
$crt++
Write-Output "$crt. $computer - Crash Dump Configuration"
MsgPrint "info" "info $crt. $computer - Crash Dump Configuration"
$file_stream_output.WriteLine("#### <Windows_CrashDump>")
try {
    Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\CrashControl\" |
    Select-Object @{N="MachineName";E = {$computer}}, CrashDumpEnabled, AutoReboot, DisableEmoticon, DumpFile, LogEvent, MinidumpDir, MinidumpsCount, OverWrite-Output |
    ConvertTo-Csv -Delimiter ';' -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch {
   $file_stream_output.WriteLine("""MachineName"";""CrashDumpEnabled""")
   $file_stream_output.WriteLine("""$computer"";""Error on getting Registry keys""")
   MsgPrint "error" "error $crt. $computer - Crash Dump - Error on getting Registry keys"
}

$file_stream_output.WriteLine("#### </Windows_CrashDump>")

<#
{% endif %}

{% if ('Windows_PKCS' in check_list or 'all' in check_list) and '-Windows_PKCS' not in check_list %}
# PKCS Configuration
##########################################################################>
# https://docs.microsoft.com/en-us/windows-server/security/tls/tls-registry-settings
# https://support.microsoft.com/en-gb/topic/microsoft-security-advisory-updated-support-for-diffie-hellman-key-exchange-f0ad89ce-dcd5-56e2-9cee-4cbb01b4da1e
$crt++
Write-Output "$crt. $computer - PKCS configuration"
MsgPrint "info" "info $crt. $computer - PKCS Configuration"
$file_stream_output.WriteLine("#### <Windows_PKCS>")
$file_stream_output.WriteLine("""MachineName"";""RSA"";""DHE"";""EccCurves"";""BestPractice""")
$RSA = $null
$DHE = $null
$EccCurves = $null
$BestPractice = "Not possible to decide automatic"
$RSA_key = Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\KeyExchangeAlgorithms\PKCS:ClientMinKeyBitLength"
try{
    If ($os -like "*2012*"){

        if (!("registry key not found","registry key empty","key extract failed").Contains($RSA_key)){
            $DHE = $RSA_key
            $RSA = $RSA_key
        }
        $EccCurves_key = Get-RegKey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Cryptography\Configuration\SSL\00010002:EccCurves"
        if (!("registry key not found","registry key empty","key extract failed").Contains($EccCurves_key)){
            $EccCurves = $EccCurves_key
        }
    }
    else{
        if (($os -like "*2016*") -or ($os -like "*2019*") -or ($os -like "*2022*")) {
            if ($RSA_key -ne "registry key not found"){
                $RSA = $RSA_key
            }
            else {
                $RSA = 1024
            }
            $DHE_key = Get-RegKey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\KeyExchangeAlgorithms\Diffie-Hellman:ClientMinKeyBitLength"
            if (!("registry key not found","registry key empty","key extract failed").Contains($DHE_key)){
                $DHE = $DHE_key
            }
            else {
                $DHE = 1024
            }
            $EccCurves =  Get-TlsEccCurve
        }
    }
    If (($RSA -ge 2048) -and ($DHE -ge 2048)) {
        $BestPractice = "OK"
    }
    $file_stream_output.WriteLine("""$computer"";""$RSA"";""$DHE"";""$EccCurves"";""$BestPractice""")
}
catch{
    MsgPrint "error" "error $crt. $computer - PKCS Configuration"
}
$file_stream_output.WriteLine("#### </Windows_PKCS>")

<#
{% endif %}

{% if ('Windows_PrintSpooler' in check_list or 'all' in check_list) and '-Windows_PrintSpooler' not in check_list %}
# PrintSpooler vulnerability
##########################################################################>
# https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527
$crt++
Write-Output "$crt. $computer - PrintSpooler vulnerability"
MsgPrint "info" "info $crt. $computer - PrintSpooler vulnerability"
$file_stream_output.WriteLine("#### <Windows_PrintSpooler>")
$file_stream_output.WriteLine("""MachineName"";""PrintServerFeature"";""PrintSpoolerService"";""NoWarningNoElevationOnInstall"";""UpdatePromptSettings"";""BestPractice""")
$PrintServerFeature = (Get-WindowsFeature -Name Print-Server).InstallState
$PrintSpoolerService = (Get-Service -Name Spooler).StartType
$NoWarningNoElevationOnInstall = $null
$UpdatePromptSettings = $null
$BestPractice = "OK"
try{
    $NoWarningNoElevationOnInstall = Get-RegKey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint:NoWarningNoElevationOnInstall"
    $UpdatePromptSettings = Get-RegKey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint:UpdatePromptSettings"
    If (($NoWarningNoElevationOnInstall -eq 1) -or ($UpdatePromptSettings -eq 1)) {
            $BestPractice = "NOT OK"
            MsgPrint "info" "info $crt. $computer - PrintSpooler vulnerability keys were found"
    }
}
catch{
    MsgPrint "error" "error $crt. $computer - PrintSpooler vulnerability keys error"
}
$file_stream_output.WriteLine("""$computer"";""$PrintServerFeature"";""$PrintSpoolerService"";""$NoWarningNoElevationOnInstall"";""$UpdatePromptSettings"";""$BestPractice""")
$file_stream_output.WriteLine("#### </Windows_PrintSpooler>")

<#
{% endif %}

{% if ('Windows_PortsOpen' in check_list or 'all' in check_list) and '-Windows_PortsOpen' not in check_list %}
# Check some ports open
##########################################################################>
#
$crt++
Write-Output "$crt. $computer - Check ports 20,21,23,69,80,119"
MsgPrint "info" "info $crt. $computer - Check ports 20,21,23,69,80,119"
$file_stream_output.WriteLine("#### <Windows_PortsOpen>")
$file_stream_output.WriteLine("""MachineName"";""Port"";""Open""")
$Ports = (20,21,23,69,80,119)
ForEach ($Port in $Ports) {
    try{
        $Port_as_string = ":"+$Port.ToString()+" "
        $conn = netstat -an | findstr /c:$Port_as_string | findstr /i /r "listening"
        $open = -not [string]::IsNullOrEmpty($conn)
        $file_stream_output.WriteLine("""$computer"";""$Port"";""$Open""")
        }
    catch{
        MsgPrint "error" "error $crt. $computer - Port $port"
    }
}
$file_stream_output.WriteLine("#### </Windows_PortsOpen>")

$file_stream_output.WriteLine("#### <Windows_NetTCPConnections>")
Get-NetTCPConnection | Select-Object -Property @{'Name'='MachineName';'Expression'={$computer}}, LocalAddress, LocalPort, RemoteAddress, RemotePort, State,OwningProcess,@{'Name'='ProcessName';'Expression'={(Get-Process -Id $_.OwningProcess).Name}} |
 Sort-Object LocalPort | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_NetTCPConnections>")

<#
{% endif %}

{% if ('Windows_HTTP_RCE' in check_list or 'all' in check_list) and '-Windows_HTTP_RCE' not in check_list %}
# Windows HTTP Protocol Stack RCE
##########################################################################>
# https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-21907
$crt++
Write-Output "$crt. $computer - Windows HTTP Protocol Stack RCE"
MsgPrint "info" "info $crt. $computer - Windows HTTP Protocol Stack RCE"
$file_stream_output.WriteLine("#### <Windows_HTTP_RCE>")
$file_stream_output.WriteLine("""MachineName"";""EnableTrailerSupport"";""BestPractice""")
$EnableTrailerSupport = $null
$BestPractice = "OK"
try{
    $EnableTrailerSupport = Get-RegKey "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\HTTP\Parameters:EnableTrailerSupport"
    if (!("registry key not found","registry key empty","key extract failed").Contains($EnableTrailerSupport)){
      $BestPractice = "NOK"
    }
}
catch{
    MsgPrint "error" "error $crt. $computer - Windows HTTP Protocol Stack RCE key EnableTrailerSupport error"
}

$file_stream_output.WriteLine("""$computer"";""$EnableTrailerSupport"";""$BestPractice""")
$file_stream_output.WriteLine("#### </Windows_HTTP_RCE>")

<#
{% endif %}

{% if ('Windows_MSDTkey' in check_list or 'all' in check_list) and '-Windows_MSDTkey' not in check_list %}
# Microsoft Support Diagnostic Tool (MSDT) in Windows vulnerability
##########################################################################>
# https://msrc-blog.microsoft.com/2022/05/30/guidance-for-cve-2022-30190-microsoft-support-diagnostic-tool-vulnerability/
$crt++
Write-Output "$crt. $computer - Microsoft Support Diagnostic Tool (MSDT) in Windows vulnerability"
MsgPrint "info" "info $crt. $computer - Microsoft Support Diagnostic Tool (MSDT) in Windows vulnerability"
$file_stream_output.WriteLine("#### </Windows_MSDT_RCE>")
$file_stream_output.WriteLine("""MachineName"";""MSDTkey"";""BestPractice""")
$MSDTkey = Get-RegKey "HKEY_CLASSES_ROOT\ms-msdt:URL_Protocol"

try {
    if ($MSDTkey -eq "registry key not found" -or $MSDTkey -eq "registry key empty"){
          $MSDTkey = "Missing"
          $BestPractice = "OK"
    } else {
            if ($MSDTkey -eq "key extract failed") {
                    $MSDTkey = "Missing"
                    $BestPractice = "Unknown"
            } else {
                $BestPractice = "NOK"
            }
    }
}
catch{
    MsgPrint "error" "error $crt. $computer - HKEY_CLASSES_ROOT\ms-msdt\URL_Protocol is $MSDTkey"
    $BestPractice = "Unknown"
}
$file_stream_output.WriteLine("""$computer"";""$MSDTkey"";""$BestPractice""")
$file_stream_output.WriteLine("#### </Windows_MSDT_RCE>")

<#
{% endif %}
#>

#------------ TECHNICAL SPECIFICATIONS related code

<#
{% if ('Windows_ad_fgp' in check_list or 'all' in check_list) and '-Windows_ad_fgp' not in check_list %}
# Windows Fine-Grained Password Policy
##########################################################################>

$crt++
Write-Output "$crt. $computer - Fine-Grained Password Policies"
MsgPrint "info" "info $crt. $computer - Fine-Grained Password Policies"
$ADFineGrainedPasswordPolicy = $null
if ($serverRoleString -in @("Primary Domain Controller","Backup Domain Controller")) {
	# ADFineGrainedPasswordPolicy are retrievable from domain controller
	try{
	    $ADFineGrainedPasswordPolicy =  Get-ADFineGrainedPasswordPolicy -Filter * -ErrorAction Stop |
	    Select Name,ComplexityEnabled,LockoutDuration,LockoutObservationWindow,LockoutThreshold,MaxPasswordAge,MinPasswordAge,MinPasswordLength,PasswordHistoryCount,ReversibleEncryptionEnabled,Precedence,AppliesTo,ObjectClass,ObjectGUID
	}
	catch{
	    MsgPrint "warning" "warning $crt. $computer - Extract FineGrainedPasswordPolicy failed on Domain controller"
	}
}
else {
        MsgPrint "warning" "warning $crt. $computer - Extract FineGrainedPasswordPolicy failed. Not Domain controller"
}

# ------------------------------------------------------

$file_stream_output.WriteLine("#### <Windows_fgpp>")
if ($ADFineGrainedPasswordPolicy -ne $null){
    $ADFineGrainedPasswordPolicy | Select @{N='DomainName';E={$DomainName}},Name,ComplexityEnabled,LockoutDuration,LockoutObservationWindow,LockoutThreshold,MaxPasswordAge,MinPasswordAge,MinPasswordLength,PasswordHistoryCount,ReversibleEncryptionEnabled,Precedence,ObjectClass,ObjectGUID |
    ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
Else{
    MsgPrint "warning" "warning $crt. $computer - Fine-Grained Password Policies: none or not Domain Contrtoller"
}
$file_stream_output.WriteLine("#### </Windows_fgpp>")

# ------------------------------------------------------

MsgPrint "info" "info $crt. $computer - Fine-Grained Password Policies details"
$file_stream_output.WriteLine("#### <Windows_fgpp_details>")
function get-recursiveInfo{
    param(
    $item,
    $parent ="" ,
    $ppatk
     )
    $objs = Get-ADObject -Identity $item -Properties *
    foreach($obj in $objs){
        if($obj.ObjectClass -eq "group"){
            $obj| select SamAccountName | Export-Csv -Delimiter ";" -Append -NoTypeInformation -Path $ppatk ####
            $Global:noofGroups += 1
            $Global:vGroupNames += $obj.sAMAccountName
            $members = Get-ADGroupMember $obj.DistinguishedName
            foreach($member in $members){
                get-recursiveInfo -item $member.DistinguishedName -parent $obj.sAMAccountName -ppatk $ppatk
            }
        }
         else{
            $obj| select SamAccountName | Export-Csv -Delimiter ";" -Append -NoTypeInformation -Path $ppatk ####
            if($parent -ne ""){
                $Global:noofUsersinGroups += 1
            }
            else{
                $Global:noofDirectUsers += 1
            }
            $Global:noofTotalUsers += 1
        }
    }
}
$FineGrainedPasswordPolicyArray = @()
$noofGroups = 0
$noofUsersinGroups = 0
$noofDirectUsers = 0
$noofTotalUsers = 0
$vGroupNames = @()

if ($null -ne $ADFineGrainedPasswordPolicy){
    foreach($policy in $ADFineGrainedPasswordPolicy){
        $FineGrainedPasswordPolicyObj = New-Object -TypeName PSObject
        $policyName = $policy.Name
        $FineGrainedPasswordPolicyObj | Add-Member -MemberType NoteProperty -Name PolicyName -Value $policyName
        $FineGrainedPolicyUsers = New-Item -ItemType "file" -Force -Path "$logdir\$crt-Fine_Grained_Password_Policy_Users-$policyName.csv"
        $Global:noofGroups = 0
        $Global:noofUsersinGroups = 0
        $Global:noofDirectUsers = 0
        $Global:noofTotalUsers = 0
        $Global:vGroupNames = @()
        foreach ($item in $policy.AppliesTo){
            get-recursiveInfo -item $item -ppatk $FineGrainedPolicyUsers
        }

        $jGroups = $Global:vGroupNames -join ","
        $FineGrainedPasswordPolicyObj | Add-Member -MemberType NoteProperty -Name Groups -Value $jGroups
        $FineGrainedPasswordPolicyObj | Add-Member -MemberType NoteProperty -Name GroupsMembers -Value $Global:noofUsersinGroups
        $FineGrainedPasswordPolicyObj | Add-Member -MemberType NoteProperty -Name DirectMembers -Value $Global:noofDirectUsers
        $FineGrainedPasswordPolicyObj | Add-Member -MemberType NoteProperty -Name TotalMembers -Value $Global:noofTotalUsers
        $FineGrainedPasswordPolicyArray += $FineGrainedPasswordPolicyObj
  }
  $FineGrainedPasswordPolicyArray | Select @{N='DomainName';E={$DomainName}},* |
  ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
Else{
  MsgPrint "warning" "$crt. Fine-Grained Password Policies details: 0 (none)"
}

$file_stream_output.WriteLine("#### </Windows_fgpp_details>")
<#
{% endif %}
#>


<#
{% if ('Windows_auditpol' in check_list or 'all' in check_list) and '-Windows_auditpol' not in check_list %}
# Windows Audit
##########################################################################>
$crt++
Write-Output "$crt. $computer - Extracting auditpol data"
MsgPrint "info" "info $crt. $computer - Extracting auditpol data"
$file_stream_output.WriteLine("#### <Windows_auditpol>")

$TemplateFilename = Join-Path ([IO.Path]::GetTempPath()) ([IO.Path]::GetRandomFileName())
$StdOut = & auditpol /backup /file:$TemplateFilename

if ( $LASTEXITCODE -eq 0 ) {
$header = 'Machine Name','Policy Target','Subcategory','Subcategory GUID','Inclusion Setting','Exclusion Setting','Setting Value'
$auditpol = import-csv $TemplateFilename -header $header


#based on https://github.com/dsccommunity/AuditPolicyDsc/blob/master/DSCResources/AuditPolicyResourceHelper/AuditPolicyResourceHelper.psm1
#contribution from Ricardo Tozelli Nolli rnolli@kyndryl.com

$AuditSubcategoryToGUIDHash = @{
    ###### Edited from "auditpol /list /subcategory:* /v"
    ######
    ######Category/Subcategory                  GUID
    ######System                                = "69979848-797A-11D9-BED3-505054503030";
    "Security State Change"                  = "0CCE9210-69AE-11D9-BED3-505054503030";
    "Security System Extension"              = "0CCE9211-69AE-11D9-BED3-505054503030";
    "System Integrity"                       = "0CCE9212-69AE-11D9-BED3-505054503030";
    "IPsec Driver"                           = "0CCE9213-69AE-11D9-BED3-505054503030";
    "Other System Events"                    = "0CCE9214-69AE-11D9-BED3-505054503030";
    ######Logon/Logoff                          = "69979849-797A-11D9-BED3-505054503030";
    "Logon"                                  = "0CCE9215-69AE-11D9-BED3-505054503030";
    "Logoff"                                 = "0CCE9216-69AE-11D9-BED3-505054503030";
    "Account Lockout"                        = "0CCE9217-69AE-11D9-BED3-505054503030";
    "IPsec Main Mode"                        = "0CCE9218-69AE-11D9-BED3-505054503030";
    "IPsec Quick Mode"                       = "0CCE9219-69AE-11D9-BED3-505054503030";
    "IPsec Extended Mode"                    = "0CCE921A-69AE-11D9-BED3-505054503030";
    "Special Logon"                          = "0CCE921B-69AE-11D9-BED3-505054503030";
    "Other Logon/Logoff Events"              = "0CCE921C-69AE-11D9-BED3-505054503030";
    "Network Policy Server"                  = "0CCE9243-69AE-11D9-BED3-505054503030";
    "User / Device Claims"                   = "0CCE9247-69AE-11D9-BED3-505054503030";
    "Group Membership"                       = "0CCE9249-69AE-11D9-BED3-505054503030";
    ######Object Access                         = "6997984A-797A-11D9-BED3-505054503030";
    "File System"                            = "0CCE921D-69AE-11D9-BED3-505054503030";
    "Registry"                               = "0CCE921E-69AE-11D9-BED3-505054503030";
    "Kernel Object"                          = "0CCE921F-69AE-11D9-BED3-505054503030";
    "SAM"                                    = "0CCE9220-69AE-11D9-BED3-505054503030";
    "Certification Services"                 = "0CCE9221-69AE-11D9-BED3-505054503030";
    "Application Generated"                  = "0CCE9222-69AE-11D9-BED3-505054503030";
    "Handle Manipulation"                    = "0CCE9223-69AE-11D9-BED3-505054503030";
    "File Share"                             = "0CCE9224-69AE-11D9-BED3-505054503030";
    "Filtering Platform Packet Drop"         = "0CCE9225-69AE-11D9-BED3-505054503030";
    "Filtering Platform Connection"          = "0CCE9226-69AE-11D9-BED3-505054503030";
    "Other Object Access Events"             = "0CCE9227-69AE-11D9-BED3-505054503030";
    "Detailed File Share"                    = "0CCE9244-69AE-11D9-BED3-505054503030";
    "Removable Storage"                      = "0CCE9245-69AE-11D9-BED3-505054503030";
    "Central Policy Staging"                 = "0CCE9246-69AE-11D9-BED3-505054503030";
    ######Privilege Use                         = "6997984B-797A-11D9-BED3-505054503030";
    "Sensitive Privilege Use"                = "0CCE9228-69AE-11D9-BED3-505054503030";
    "Non Sensitive Privilege Use"            = "0CCE9229-69AE-11D9-BED3-505054503030";
    "Other Privilege Use Events"             = "0CCE922A-69AE-11D9-BED3-505054503030";
    ######Detailed Tracking                     = "6997984C-797A-11D9-BED3-505054503030";
    "Process Creation"                       = "0CCE922B-69AE-11D9-BED3-505054503030";
    "Process Termination"                    = "0CCE922C-69AE-11D9-BED3-505054503030";
    "DPAPI Activity"                         = "0CCE922D-69AE-11D9-BED3-505054503030";
    "RPC Events"                             = "0CCE922E-69AE-11D9-BED3-505054503030";
    "Plug and Play Events"                   = "0CCE9248-69AE-11D9-BED3-505054503030";
    "Token Right Adjusted Events"            = "0CCE924A-69AE-11D9-BED3-505054503030";
    ######Policy Change                         = "6997984D-797A-11D9-BED3-505054503030";
    "Audit Policy Change"                    = "0CCE922F-69AE-11D9-BED3-505054503030";
    "Authentication Policy Change"           = "0CCE9230-69AE-11D9-BED3-505054503030";
    "Authorization Policy Change"            = "0CCE9231-69AE-11D9-BED3-505054503030";
    "MPSSVC Rule-Level Policy Change"        = "0CCE9232-69AE-11D9-BED3-505054503030";
    "Filtering Platform Policy Change"       = "0CCE9233-69AE-11D9-BED3-505054503030";
    "Other Policy Change Events"             = "0CCE9234-69AE-11D9-BED3-505054503030";
    ######Account Management                    = "6997984E-797A-11D9-BED3-505054503030";
    "User Account Management"                = "0CCE9235-69AE-11D9-BED3-505054503030";
    "Computer Account Management"            = "0CCE9236-69AE-11D9-BED3-505054503030";
    "Security Group Management"              = "0CCE9237-69AE-11D9-BED3-505054503030";
    "Distribution Group Management"          = "0CCE9238-69AE-11D9-BED3-505054503030";
    "Application Group Management"           = "0CCE9239-69AE-11D9-BED3-505054503030";
    "Other Account Management Events"        = "0CCE923A-69AE-11D9-BED3-505054503030";
    ######DS Access                             = "6997984F-797A-11D9-BED3-505054503030";
    "Directory Service Access"               = "0CCE923B-69AE-11D9-BED3-505054503030";
    "Directory Service Changes"              = "0CCE923C-69AE-11D9-BED3-505054503030";
    "Directory Service Replication"          = "0CCE923D-69AE-11D9-BED3-505054503030";
    "Detailed Directory Service Replication" = "0CCE923E-69AE-11D9-BED3-505054503030";
    ######Account Logon                         = "69979850-797A-11D9-BED3-505054503030";
    "Credential Validation"                  = "0CCE923F-69AE-11D9-BED3-505054503030";
    "Kerberos Service Ticket Operations"     = "0CCE9240-69AE-11D9-BED3-505054503030";
    "Other Account Logon Events"             = "0CCE9241-69AE-11D9-BED3-505054503030";
    "Kerberos Authentication Service"        = "0CCE9242-69AE-11D9-BED3-505054503030";
}

# $AuditSubcategoryToGUIDHash = (auditpol /list /subcategory:* /v /r).trim() | convertfrom-csv

$AuditGUIDToSubCategoryHash = @{}
$AuditSubcategoryToGUIDHash.Keys | ForEach-Object {
    $AuditGUIDToSubCategoryHash.Add($AuditSubcategoryToGUIDHash[$_], $_)
}


$AuditSettingValueToFlag = @(
    'No Auditing',
    'Success',
    'Failure',
    'Success and Failure'
)
$auditpolonly = $auditpol | Where-Object {!([string]::IsNullOrEmpty($_.'Subcategory GUID'))} | select -skip 1

Write-Verbose "Creating report array"
$audititem = @()
$auditconfig = @()

foreach($audit in $auditpolonly){
    $audititem=new-object psobject
    $audititem | add-member -MemberType NoteProperty -name MachineName -Value $($env:computername)
    $audititem | add-member -MemberType NoteProperty -name AuditPolicy -Value $($AuditGUIDToSubCategoryHash[($audit."Subcategory GUID").replace('{','').replace('}','')])
    $audititem | add-member -MemberType NoteProperty -name Setting -Value $($AuditSettingValueToFlag[$audit."Setting Value"])
    $auditconfig += $audititem
}
$auditconfig | sort AuditPolicy | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}

Remove-Item $TemplateFilename -ErrorAction SilentlyContinue

} else {
    msgprint "error" "error $crt. $computer - AuditPol"
}
$file_stream_output.WriteLine("#### </Windows_auditpol>")


<#
{% endif %}
#>

<#
{% if ('Windows_acl_audit' in check_list  or 'all' in check_list) and '-Windows_acl_audit' not in check_list %}
#>
$crt++
MsgPrint "info" "info $crt. $computer - Extracting ACL audit data"
$file_stream_output.WriteLine("#### <Windows_acl_audit>")

$aclitems = @(
	"$Env:SystemRoot",
    "$Env:SystemRoot\Security",
	"$Env:SystemRoot\System",
	"$Env:SystemRoot\System32",
	"$Env:SystemRoot\system32\Config",
	"$Env:SystemRoot\System32\Drivers",
	"$Env:SystemRoot\System32\Spool",
	"$Env:SystemRoot\system32\GroupPolicy",
	"$Env:SystemRoot\WinSxS\Backup",
	"$Env:SystemRoot\system32\winload.efi",
	"$Env:SystemDrive",
    "$Env:SystemDrive\bootmgr",
	"$Env:SystemRoot\syswow64",
	"$Env:SystemRoot\syswow64\drivers",
	"$Env:SystemRoot\System32\Winevt\Logs\Security.evtx",
	"$Env:SystemRoot\System32\Winevt\Logs\Microsoft-Windows-PowerShell%4Operational.evtx",
	"C:\EFI\Microsoft\Boot\bootmgfw.efi",
    "$Env:SystemRoot\system32\winload.exe"
)

$aclarray = @()
Foreach ($item in $aclitems) {

	$acl = $null
	if (Test-Path $item) { $acl = get-acl $item -Audit | ForEach-Object { $_.Audit } }

    if ($acl.count -ge 2) {
        Foreach ($line in $acl) {
        	$obj = '' | select-object Path,FileSystemRights,AuditFlags,IdentityReference,IsInherited,InheritanceFlags,PropagationFlags
	        $obj.path = $item
	        $obj.FileSystemRights =  ($line.FileSystemRights -join ",")
	        $obj.AuditFlags = ($line.AuditFlags -join ",")
	        $obj.IdentityReference = ($line.IdentityReference -join ",")
	        $obj.IsInherited = ($line.IsInherited -join ",")
	        $obj.InheritanceFlags = ($line.InheritanceFlags -join ",")
	        $obj.PropagationFlags = ($line.PropagationFlags -join ",")
	        $aclarray += $obj
        }
    }
    else {
    	$obj = '' | select-object Path,FileSystemRights,AuditFlags,IdentityReference,IsInherited,InheritanceFlags,PropagationFlags
	    $obj.path = $item
	    $obj.FileSystemRights =  ($acl.FileSystemRights -join ",")
	    $obj.AuditFlags = ($acl.AuditFlags -join ",")
	    $obj.IdentityReference = ($acl.IdentityReference -join ",")
	    $obj.IsInherited = ($acl.IsInherited -join ",")
	    $obj.InheritanceFlags = ($acl.InheritanceFlags -join ",")
	    $obj.PropagationFlags = ($acl.PropagationFlags -join ",")
	    $aclarray += $obj
    }
}
$aclarray | convertto-csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
$file_stream_output.WriteLine("#### </Windows_acl_audit>")

<#
{% endif %}
#>

<#
{% if ('secedit' in check_list  or 'all' in check_list) and '-secedit' not in check_list %}
# Windows Secedit
#>
$crt++
Write-Output "$crt. $computer - Extracting secedit data"
msgprint "info" "info $crt. $computer - Extracting secedit data"

# Use LookupPrivilegeDisplayName Win32 API to get display name of privilege
# (except for user logon rights)
function Get-PrivilegeDisplayName {
    param(
    [String] $name
    )
    $displayNameSB = New-Object System.Text.StringBuilder 1024
    $languageId = 0
    $ok = $AdvApi32::LookupPrivilegeDisplayName($null, $name, $displayNameSB, [Ref] $displayNameSB.Capacity, [Ref] $languageId)
    if ( $ok ) {
    $displayNameSB.ToString()
    }
    else {
    # Doesn't lookup logon rights, so use hashtable for that
    if ( $UserLogonRights[$name] ) {
        $UserLogonRights[$name]
    }
    else {
        $name
    }
    }
}

# Outputs list of hashtables as a PSObject
function Out-Object {
    param(
    [System.Collections.Hashtable[]] $hashData
    )
    $order = @()
    $result = @{}
    $hashData | ForEach-Object {
    $order += ($_.Keys -as [Array])[0]
    $result += $_
    }
    New-Object PSObject -Property $result | Select-Object $order
}

# Translates a SID in the form *S-1-5-... to its account name;
function Get-AccountName {
    param(
    [String] $principal
    )
    if ( $principal[0] -eq "*" ) {
    $sid = New-Object System.Security.Principal.SecurityIdentifier($principal.Substring(1))
    Try {$out = $sid.Translate([Security.Principal.NTAccount])}
    catch
        {
        $out = $principal
        }
    $out
    }
    else {
    $principal
    }
}

# LookupPrivilegeDisplayName Win32 API doesn't resolve logon right display
# names, so use this hashtable
$UserLogonRights = @{
    "SeBatchLogonRight"                 = "Log on as a batch job"
    "SeDenyBatchLogonRight"             = "Deny log on as a batch job"
    "SeDenyInteractiveLogonRight"       = "Deny log on locally"
    "SeDenyNetworkLogonRight"           = "Deny access to this computer from the network"
    "SeDenyRemoteInteractiveLogonRight" = "Deny log on through Remote Desktop Services"
    "SeDenyServiceLogonRight"           = "Deny log on as a service"
    "SeInteractiveLogonRight"           = "Allow log on locally"
    "SeNetworkLogonRight"               = "Access this computer from the network"
    "SeRemoteInteractiveLogonRight"     = "Allow log on through Remote Desktop Services"
    "SeServiceLogonRight"               = "Log on as a service"
}

# Empty out if we can't find SecEdit.exe
$SecEdit = Join-Path ([Environment]::GetFolderPath([Environment+SpecialFolder]::System)) "SecEdit.exe"

# Create type to invoke LookupPrivilegeDisplayName Win32 API
$Win32APISignature = @'
[DllImport("advapi32.dll", SetLastError=true)]
public static extern bool LookupPrivilegeDisplayName(
    string systemName,
    string privilegeName,
    System.Text.StringBuilder displayName,
    ref uint cbDisplayName,
    out uint languageId
);
'@
$AdvApi32 = Add-Type advapi32 $Win32APISignature -Namespace LookupPrivilegeDisplayName -PassThru

if (Test-Path $SecEdit) {
    $seceditFile = [System.IO.Path]::GetTempFileName()
    $rtncode = secedit /export /cfg $seceditFile /quiet

    if (Test-Path $seceditFile) {
        $seceditdata = get-inifile $seceditFile
        Remove-Item $seceditFile -Force -Confirm:$false
    }
    foreach ($key in $seceditdata.Keys) {
        $segment_name = "Windows_secedit_$key" -replace " ","_"
        $file_stream_output.WriteLine("#### <$segment_name>")
        ($seceditdata[$key]).GetEnumerator() | Select-Object @{n="MachineName";e={$Computer}},key,value | ConvertTo-Csv -Delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
        $file_stream_output.WriteLine("#### </$segment_name>")
    }

    $file_stream_output.WriteLine("#### <Windows_secedit_USER_RIGHTS>")
    $TemplateFilename = Join-Path ([IO.Path]::GetTempPath()) ([IO.Path]::GetRandomFileName())
    $LogFilename = Join-Path ([IO.Path]::GetTempPath()) ([IO.Path]::GetRandomFileName())
    $StdOut = & $SecEdit /export /cfg $TemplateFilename /areas USER_RIGHTS /log $LogFilename
    if ( $LASTEXITCODE -eq 0 ) {
        Select-String '^(Se\S+) = (.+)' $TemplateFilename | Foreach-Object {
        $Privilege = $_.Matches[0].Groups[1].Value
        $Principals = $_.Matches[0].Groups[2].Value -split ','
        foreach ( $Principal in $Principals ) {
            Out-Object `
            @{"MachineName" = $computer},
            @{"Privilege" = $Privilege},
            @{"PrivilegeName" = Get-PrivilegeDisplayName $Privilege},
            @{"Principal" = Get-AccountName $Principal},
            @{"SID" = $Principal}
        }
        }  | convertto-csv -delimiter ';' -notypeinformation | foreach-object {$file_stream_output.WriteLine($_)}
    }
    else {
        $OFS = ""
        Write-Error "$StdOut"
    }
    Remove-Item $TemplateFilename,$LogFilename -ErrorAction SilentlyContinue

    $file_stream_output.WriteLine("#### </Windows_secedit_USER_RIGHTS>")
}
else {
  MsgPrint error "error $crt. $computer - File not found - '$SecEdit'" -Category ObjectNotFound
  $file_stream_output.WriteLine("#### <Windows_secedit_Privilege_Rights>")
  $file_stream_output.WriteLine("#### </Windows_secedit_Privilege_Rights>")
  $file_stream_output.WriteLine("#### <Windows_secedit_System_Access>")
  $file_stream_output.WriteLine("#### </Windows_secedit_System_Access>")
  $file_stream_output.WriteLine("#### <Windows_secedit_Event_Audit>")
  $file_stream_output.WriteLine("#### </Windows_secedit_Event_Audit>")
  $file_stream_output.WriteLine("#### <Windows_secedit_Registry_Values>")
  $file_stream_output.WriteLine("#### </Windows_secedit_Registry_Values>")
  $file_stream_output.WriteLine("#### <Windows_secedit_USER_RIGHTS>")
  $file_stream_output.WriteLine("#### </Windows_ecedits_USER_RIGHTS>")
}

<#
{% endif %}
#>

<#
{% if ('registry' in check_list  or 'all' in check_list) and '-registry' not in check_list %}
# Windows Registry keys
#>

$crt++
Write-Output "$crt. $computer - Extracting registry keys"
msgprint "info" "info $crt. $computer - Extracting registry keys"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:SCENoApplyLegacyAuditPolicy" -segment_name "Windows_Reg_Lsa:SCENoApplyLegacyAuditPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoDriveTypeAutoRun" -segment_name "Windows_Reg_Explorer:NoDriveTypeAutoRun"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Explorer:NoAutoplayfornonVolume" -segment_name "Windows_Reg_Explorer:NoAutoplayfornonVolume"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoAutorun" -segment_name "Windows_Reg_Explorer:NoAutorun"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Group Policy\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}:NoBackgroundPolicy" -segment_name "Windows_Reg_GP:NoBackgroundPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Group Policy\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}:NoGPOListChanges" -segment_name "Windows_Reg_GP:NoGPOListChanges"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:DisableBkGndGroupPolicy" -segment_name "Windows_Reg_System:DisableBkGndGroupPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:BlockUserFromShowingAccountDetailsOnSignin" -segment_name "Windows_Reg_System:BlockUserFromShowingAccountDetailsOnSignin"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:DontDisplayNetworkSelectionUI" -segment_name "Windows_Reg_System:DontDisplayNetworkSelectionUI"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:DontEnumerateConnectedUsers" -segment_name "Windows_Reg_System:DontEnumerateConnectedUsers"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:EnumerateLocalUsers" -segment_name "Windows_Reg_System:EnumerateLocalUsers"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:fAllowUnsolicited" -segment_name "Windows_Reg_TS:fAllowUnsolicited"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:fAllowToGetHelp" -segment_name "Windows_Reg_TS:fAllowToGetHelp"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Connect:RequirePinForPairing" -segment_name "Windows_Reg_Connect:RequirePinForPairing"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\CredUI:EnumerateAdministrators" -segment_name "Windows_Reg_CredUI:EnumerateAdministrators"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Security:AutoBackupLogFiles" -segment_name "Windows_Reg_Security:AutoBackupLogFiles"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\System:AutoBackupLogFiles" -segment_name "Windows_Reg_System:AutoBackupLogFiles"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Application:AutoBackupLogFiles" -segment_name "Windows_Reg_Application:AutoBackupLogFiles"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Security:Retention" -segment_name "Windows_Reg_Security:Retention"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\System:Retention" -segment_name "Windows_Reg_System:Retention"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Application:Retention" -segment_name "Windows_Reg_Application:Retention"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\OneDrive:DisableFileSyncNGSC" -segment_name "Windows_Reg_OneDrive:DisableFileSyncNGSC"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:DisablePasswordSaving" -segment_name "Windows_Reg_TS:DisablePasswordSaving"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsInkWorkspace:AllowWindowsInkWorkspace" -segment_name "Windows_Reg_WindowsInkWorkspace:AllowWindowsInkWorkspace"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer:EnableUserControl" -segment_name "Windows_Reg_Installer:EnableUserControl"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:DisableAutomaticRestartSignOn" -segment_name "Windows_Reg_System:DisableAutomaticRestartSignOn"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging:EnableScriptBlockLogging" -segment_name "Windows_Reg_ScriptBlockLogging:EnableScriptBlockLogging"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription:EnableTranscripting" -segment_name "Windows_Reg_Transcription:EnableTranscripting"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRM\Client:AllowBasic" -segment_name "Windows_Reg_Client:AllowBasic"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRM\Client:AllowUnencryptedTraffic" -segment_name "Windows_Reg_Client:AllowUnencryptedTraffic"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRM\Client:AllowDigest" -segment_name "Windows_Reg_Client:AllowDigest"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRM\Service:AllowBasic" -segment_name "Windows_Reg_Service:AllowBasic"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRM\Service:AllowUnencryptedTraffic" -segment_name "Windows_Reg_Service:AllowUnencryptedTraffic"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRM\Service:DisableRunAs" -segment_name "Windows_Reg_Service:DisableRunAs"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender Security Center\App and Browser protection:DisallowExploitProtectionOverride" -segment_name "Windows_Reg_Def:DisallowExploitProtectionOverride"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Security:MaxSize" -segment_name "Windows_Reg_Security:MaxSize"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\System:MaxSize" -segment_name "Windows_Reg_System:MaxSize"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Application:MaxSize" -segment_name "Windows_Reg_Application:MaxSize"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:FilterAdministratorToken" -segment_name "Windows_Reg_System:FilterAdministratorToken"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:ConsentPromptBehaviorAdmin" -segment_name "Windows_Reg_System:ConsentPromptBehaviorAdmin"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:ConsentPromptBehaviorUser" -segment_name "Windows_Reg_System:ConsentPromptBehaviorUser"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:EnableInstallerDetection" -segment_name "Windows_Reg_System:EnableInstallerDetection"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:EnableSecureUIAPaths" -segment_name "Windows_Reg_System:EnableSecureUIAPaths"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:EnableLUA" -segment_name "Windows_Reg_System:EnableLUA"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:PromptOnSecureDesktop" -segment_name "Windows_Reg_System:PromptOnSecureDesktop"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:EnableVirtualization" -segment_name "Windows_Reg_System:EnableVirtualization"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:legalnoticecaption" -segment_name "Windows_Reg_System:legalnoticecaption"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:legalNoticeText" -segment_name "Windows_Reg_System:legalNoticeText"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:ShutdownWithoutLogon" -segment_name "Windows_Reg_System:ShutdownWithoutLogon"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:disablecad" -segment_name "Windows_Reg_System:disablecad"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:dontdisplaylastusername" -segment_name "Windows_Reg_System:dontdisplaylastusername"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:CachedLogonsCount" -segment_name "Windows_Reg_Winlogon:CachedLogonsCount"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:ForceUnlockLogon" -segment_name "Windows_Reg_Winlogon:ForceUnlockLogon"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:SCRemoveOption" -segment_name "Windows_Reg_Winlogon:SCRemoveOption"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:InactivityTimeoutSecs" -segment_name "Windows_Reg_System:InactivityTimeoutSecs"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:PasswordExpiryWarning" -segment_name "Windows_Reg_Winlogon:PasswordExpiryWarning"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters:RequireSecuritySignature" -segment_name "Windows_Reg_LanManW:RequireSecuritySignature"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters:EnableSecuritySignature" -segment_name "Windows_Reg_LanManW:EnableSecuritySignature"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters:EnablePlainTextPassword" -segment_name "Windows_Reg_LanManW:EnablePlainTextPassword"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa:TurnOffAnonymousBlock" -segment_name "Windows_Reg_Lsa:TurnOffAnonymousBlock"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa:RestrictAnonymousSAM" -segment_name "Windows_Reg_Lsa:RestrictAnonymousSAM"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa:EveryoneIncludesAnonymous" -segment_name "Windows_Reg_Lsa:EveryoneIncludesAnonymous"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:NullSessionPipes" -segment_name "Windows_Reg_LanManS:NullSessionPipes"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:restrictanonymous" -segment_name "Windows_Reg_Lsa:restrictanonymous"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:DisableDomainCreds" -segment_name "Windows_Reg_Lsa:DisableDomainCreds"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:UseMachineId" -segment_name "Windows_Reg_Lsa:UseMachineId"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:LmCompatibilityLevel" -segment_name "Windows_Reg_Lsa:LmCompatibilityLevel"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0:NTLMMinClientSec" -segment_name "Windows_Reg_MSV1_0:NTLMMinClientSec"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0:NTLMMinServerSec" -segment_name "Windows_Reg_MSV1_0:NTLMMinServerSec"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:NoLMHash" -segment_name "Windows_Reg_Lsa:NoLMHash"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurePipeServers\Winreg\AllowedExactPaths:Machine" -segment_name "Windows_Reg_AllowedExactPaths:Machine"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurePipeServers\Winreg\AllowedPaths:Machine" -segment_name "Windows_Reg_AllowedPaths:Machine"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:RestrictNullSessAccess" -segment_name "Windows_Reg_Parameters:RestrictNullSessAccess"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:restrictremotesam" -segment_name "Windows_Reg_Lsa:restrictremotesam"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:NullSessionShares" -segment_name "Windows_Reg_Parameters:NullSessionShares"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:ForceGuest" -segment_name "Windows_Reg_Lsa:ForceGuest"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0:AllowNullSessionFallback" -segment_name "Windows_Reg_MSV1_0:AllowNullSessionFallback"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\pku2u:AllowOnlineID" -segment_name "Windows_Reg_pku2u:AllowOnlineID"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\Kerberos\Parameters:SupportedEncryptionTypes" -segment_name "Windows_Reg_Parameters:SupportedEncryptionTypes"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LDAP:LDAPClientIntegrity" -segment_name "Windows_Reg_LDAP:LDAPClientIntegrity"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:NoConnectedUser" -segment_name "Windows_Reg_System:NoConnectedUser"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:LimitBlankPasswordUse" -segment_name "Windows_Reg_Lsa:LimitBlankPasswordUse"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:CrashOnAuditFail" -segment_name "Windows_Reg_Lsa:CrashOnAuditFail"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:AllocateDASD" -segment_name "Windows_Reg_Winlogon:AllocateDASD"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Providers\LanMan Print Services\Servers:AddPrinterDrivers" -segment_name "Windows_Reg_Servers:AddPrinterDrivers"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:SubmitControl" -segment_name "Windows_Reg_Lsa:SubmitControl"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:VulnerableChannelAllowList" -segment_name "Windows_Reg_Parameters:VulnerableChannelAllowList"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters:LdapEnforceChannelBinding" -segment_name "Windows_Reg_Parameters:LdapEnforceChannelBinding"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters:LDAPServerIntegrity" -segment_name "Windows_Reg_Parameters:LDAPServerIntegrity"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:RefusePasswordChange" -segment_name "Windows_Reg_Parameters:RefusePasswordChange"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:RequireSignOrSeal" -segment_name "Windows_Reg_Parameters:RequireSignOrSeal"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:SealSecureChannel" -segment_name "Windows_Reg_Parameters:SealSecureChannel"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:SignSecureChannel" -segment_name "Windows_Reg_Parameters:SignSecureChannel"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:DisablePasswordChange" -segment_name "Windows_Reg_Parameters:DisablePasswordChange"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters:MaximumPasswordAge" -segment_name "Windows_Reg_Parameters:MaximumPasswordAge"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:RequireStrongKey" -segment_name "Windows_Reg_Parameters:RequireStrongKey"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:AutoDisconnect" -segment_name "Windows_Reg_Parameters:AutoDisconnect"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:RequireSecuritySignature" -segment_name "Windows_Reg_LanManS:RequireSecuritySignature"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:EnableSecuritySignature" -segment_name "Windows_Reg_LanManS:EnableSecuritySignature"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:enableforcedlogoff" -segment_name "Windows_Reg_Parameters:enableforcedlogoff"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanManServer\Parameters:SMBServerNameHardeningLevel" -segment_name "Windows_Reg_Parameters:SMBServerNameHardeningLevel"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel:ObCaseInsensitive" -segment_name "Windows_Reg_SM_Kernel:ObCaseInsensitive"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager:ProtectionMode" -segment_name "Windows_Reg_SM:ProtectionMode"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Spooler:Start" -segment_name "Windows_Reg_Spooler:Start"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile:EnableFirewall" -segment_name "Windows_Reg_FWDomain:EnableFirewall"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile:DefaultInboundAction" -segment_name "Windows_Reg_FWDomain:DefaultInboundAction"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile:DefaultOutboundAction" -segment_name "Windows_Reg_FWDomain:DefaultOutboundAction"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile:DisableNotifications" -segment_name "Windows_Reg_FWDomain:DisableNotifications"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile\Logging:LogFilePath" -segment_name "Windows_Reg_FWDomain:LogFilePath"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile\Logging:LogFileSize" -segment_name "Windows_Reg_FWDomain:LogFileSize"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile\Logging:LogDroppedPackets" -segment_name "Windows_Reg_FWDomain:LogDroppedPackets"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile\Logging:LogSuccessfulConnections" -segment_name "Windows_Reg_FWDomain:LogSuccessfulConnections"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile:EnableFirewall" -segment_name "Windows_Reg_FWPrivate:EnableFirewall"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile:DefaultInboundAction" -segment_name "Windows_Reg_FWPrivate:DefaultInboundAction"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile:DefaultOutboundAction" -segment_name "Windows_Reg_FWPrivate:DefaultOutboundAction"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile:DisableNotifications" -segment_name "Windows_Reg_FWPrivate:DisableNotifications"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile\Logging:LogFilePath" -segment_name "Windows_Reg_FWPrivate:LogFilePath"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile\Logging:LogFileSize" -segment_name "Windows_Reg_FWPrivate:LogFileSize"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile\Logging:LogDroppedPackets" -segment_name "Windows_Reg_FWPrivate:LogDroppedPackets"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PrivateProfile\Logging:LogSuccessfulConnections" -segment_name "Windows_Reg_FWPrivate:LogSuccessfulConnections"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile:EnableFirewall" -segment_name "Windows_Reg_FWPublic:EnableFirewall"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile:DefaultInboundAction" -segment_name "Windows_Reg_FWPublic:DefaultInboundAction"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile:DefaultOutboundAction" -segment_name "Windows_Reg_FWPublic:DefaultOutboundAction"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile:DisableNotifications" -segment_name "Windows_Reg_FWPublic:DisableNotifications"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile:AllowLocalPolicyMerge" -segment_name "Windows_Reg_FWPublic:AllowLocalPolicyMerge"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile:AllowLocalIPsecPolicyMerge" -segment_name "Windows_Reg_FWPublic:AllowLocalIPsecPolicyMerge"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile\Logging:LogFilePath" -segment_name "Windows_Reg_FWPublic:LogFilePath"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile\Logging:LogFileSize" -segment_name "Windows_Reg_FWPublic:LogFileSize"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile\Logging:LogDroppedPackets" -segment_name "Windows_Reg_FWPublic:LogDroppedPackets"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsFirewall\PublicProfile\Logging:LogSuccessfulConnections" -segment_name "Windows_Reg_FWPublic:LogSuccessfulConnections"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Personalization:NoLockScreenCamera" -segment_name "Windows_Reg_Pers:NoLockScreenCamera"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Personalization:NoLockScreenSlideshow" -segment_name "Windows_Reg_Pers:NoLockScreenSlideshow"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\InputPersonalization:AllowInputPersonalization" -segment_name "Windows_Reg_InputPers:AllowInputPersonalization"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions\{D76B9641-3288-4f75-942D-087DE603E3EA}:DllName" -segment_name "Windows_Reg_GPExtensions:DllName"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft Services\AdmPwd:PwdExpirationProtectionEnabled" -segment_name "Windows_Reg_AdmPwd:PwdExpirationProtectionEnabled"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft Services\AdmPwd:AdmPwdEnabled" -segment_name "Windows_Reg_AdmPwd:AdmPwdEnabled"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft Services\AdmPwd:PasswordComplexity" -segment_name "Windows_Reg_AdmPwd:PasswordComplexity"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft Services\AdmPwd:PasswordLength" -segment_name "Windows_Reg_AdmPwd:PasswordLength"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft Services\AdmPwd:PasswordAgeDays" -segment_name "Windows_Reg_AdmPwd:PasswordAgeDays"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:LocalAccountTokenFilterPolicy" -segment_name "Windows_Reg_System:LocalAccountTokenFilterPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\mrxsmb10:Start" -segment_name "Windows_Reg_mrxsmb10:Start"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters:SMB1" -segment_name "Windows_Reg_LanManS:SMB1"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel:DisableExceptionChainValidation" -segment_name "Windows_Reg_kernel:DisableExceptionChainValidation"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NetBT\Parameters:NodeType" -segment_name "Windows_Reg_NetBT:NodeType"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest:UseLogonCredential" -segment_name "Windows_Reg_WDigest:UseLogonCredential"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print:RpcAuthnLevelPrivacyEnabled" -segment_name "Windows_Reg_Print:RpcAuthnLevelPrivacyEnabled"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:AutoAdminLogon" -segment_name "Windows_Reg_Winlogon:AutoAdminLogon"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters:DisableIPSourceRouting" -segment_name "Windows_Reg_Tcpip6:DisableIPSourceRouting"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters:DisableIPSourceRouting" -segment_name "Windows_Reg_Tcpip:DisableIPSourceRouting"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters:EnableICMPRedirect" -segment_name "Windows_Reg_Tcpip:EnableICMPRedirect"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NetBT\Parameters:NoNameReleaseOnDemand" -segment_name "Windows_Reg_NetBT:NoNameReleaseOnDemand"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager:SafeDllSearchMode" -segment_name "Windows_Reg_SM:SafeDllSearchMode"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon:ScreenSaverGracePeriod" -segment_name "Windows_Reg_Winlogon:ScreenSaverGracePeriod"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Security:WarningLevel" -segment_name "Windows_Reg_Evnt_Security:WarningLevel"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient:EnableMulticast" -segment_name "Windows_Reg_DNSClient:EnableMulticast"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient:EnableNetbios" -segment_name "Windows_Reg_DNSClient:EnableNetbios"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\LanmanWorkstation:AllowInsecureGuestAuth" -segment_name "Windows_Reg_LanmanW:AllowInsecureGuestAuth"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Network Connections:NC_AllowNetBridge_NLA" -segment_name "Windows_Reg_NC:NC_AllowNetBridge_NLA"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Network Connections:NC_ShowSharedAccessUI" -segment_name "Windows_Reg_NC:NC_ShowSharedAccessUI"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Network Connections:NC_StdDomainUserSetLocation" -segment_name "Windows_Reg_NC:NC_StdDomainUserSetLocation"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\NetworkProvider\HardenedPaths:\\*\NETLOGON" -segment_name "Windows_Reg_HardenedPaths:\\*\NETLOGON"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\NetworkProvider\HardenedPaths:\\*\SYSVOL" -segment_name "Windows_Reg_HardenedPaths:\\*\SYSVOL"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WcmSvc\GroupPolicy:fMinimizeConnections" -segment_name "Windows_Reg_GroupPolicy:fMinimizeConnections"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows NT\Printers:RegisterSpoolerRemoteRpcEndPoint" -segment_name "Windows_Reg_Printers:RegisterSpoolerRemoteRpcEndPoint"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows NT\Printers\PointAndPrint:NoWarningNoElevationOnInstall" -segment_name "Windows_Reg_PointAndPrint:NoWarningNoElevationOnInstall"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows NT\Printers\PointAndPrint:UpdatePromptSettings" -segment_name "Windows_Reg_PointAndPrint:UpdatePromptSettings"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers:RedirectionguardPolicy" -segment_name "Windows_Reg_Printers:RedirectionguardPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\RPC:RpcUseNamedPipeProtocol" -segment_name "Windows_Reg_RPC:RpcUseNamedPipeProtocol"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\RPC:RpcAuthentication" -segment_name "Windows_Reg_RPC:RpcAuthentication"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\RPC:RpcProtocols" -segment_name "Windows_Reg_RPC:RpcProtocols"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\RPC:ForceKerberosForRpc" -segment_name "Windows_Reg_RPC:ForceKerberosForRpc"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\RPC:RpcTcpPort" -segment_name "Windows_Reg_RPC:RpcTcpPort"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint:RestrictDriverInstallationToAdministrators" -segment_name "Windows_Reg_PointAndPrint:RestrictDriverInstallationToAdministrators"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers:CopyFilesPolicy" -segment_name "Windows_Reg_Printers:CopyFilesPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\Audit:ProcessCreationIncludeCmdLine_Enabled" -segment_name "Windows_Reg_Audit:ProcessCreationIncludeCmdLine_Enabled"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\CredSSP\Parameters:AllowEncryptionOracle" -segment_name "Windows_Reg_Parameters:AllowEncryptionOracle"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation:AllowProtectedCreds" -segment_name "Windows_Reg_CredentialsDelegation:AllowProtectedCreds"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Device Metadata:PreventDeviceMetadataFromNetwork" -segment_name "Windows_Reg_DeviceMetadata:PreventDeviceMetadataFromNetwork"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Policies\EarlyLaunch:DriverLoadPolicy" -segment_name "Windows_Reg_EarlyLaunch:DriverLoadPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:EnableCdp" -segment_name "Windows_Reg_System:EnableCdp"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers:DisableWebPnPDownload" -segment_name "Windows_Reg_Printers:DisableWebPnPDownload"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoWebServices" -segment_name "Windows_Reg_Explorer:NoWebServices"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Kernel DMA Protection:DeviceEnumerationPolicy" -segment_name "Windows_Reg_KernelDMAProtection:DeviceEnumerationPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:DisableLockScreenAppNotifications" -segment_name "Windows_Reg_System:DisableLockScreenAppNotifications"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:BlockDomainPicturePassword" -segment_name "Windows_Reg_System:BlockDomainPicturePassword"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:AllowDomainPINLogon" -segment_name "Windows_Reg_System:AllowDomainPINLogon"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Power\PowerSettings\0e796bdb-100d-47d6-a2d5-f7d2daa51f51:DCSettingIndex" -segment_name "Windows_Reg_Power:DCSettingIndex"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Power\PowerSettings\0e796bdb-100d-47d6-a2d5-f7d2daa51f51:ACSettingIndex" -segment_name "Windows_Reg_Power:ACSettingIndex"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Rpc:EnableAuthEpResolution" -segment_name "Windows_Reg_Rpc:EnableAuthEpResolution"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\SAM:SamNGCKeyROCAValidation" -segment_name "Windows_Reg_SAM:SamNGCKeyROCAValidation"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:MSAOptional" -segment_name "Windows_Reg_System:MSAOptional"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Biometrics\FacialFeatures:EnhancedAntiSpoofing" -segment_name "Windows_Reg_FacialFeatures:EnhancedAntiSpoofing"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CloudContent:DisableConsumerAccountStateContent" -segment_name "Windows_Reg_CloudContent:DisableConsumerAccountStateContent"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CloudContent:DisableWindowsConsumerFeatures" -segment_name "Windows_Reg_CloudContent:DisableWindowsConsumerFeatures"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredUI:DisablePasswordReveal" -segment_name "Windows_Reg_CredUI:DisablePasswordReveal"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection:AllowTelemetry" -segment_name "Windows_Reg_DataCollection:AllowTelemetry"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection:DisableOneSettingsDownloads" -segment_name "Windows_Reg_DataCollection:DisableOneSettingsDownloads"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection:DoNotShowFeedbackNotifications" -segment_name "Windows_Reg_DataCollection:DoNotShowFeedbackNotifications"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection:EnableOneSettingsAuditing" -segment_name "Windows_Reg_DataCollection:EnableOneSettingsAuditing"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection:LimitDiagnosticLogCollection" -segment_name "Windows_Reg_DataCollection:LimitDiagnosticLogCollection"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\DataCollection:LimitDumpCollection" -segment_name "Windows_Reg_DataCollection:LimitDumpCollection"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PreviewBuilds:AllowBuildPreview" -segment_name "Windows_Reg_PreviewBuilds:AllowBuildPreview"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Setup:MaxSize" -segment_name "Windows_Reg_Setup:MaxSize"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\EventLog\Setup:Retention" -segment_name "Windows_Reg_Setup:Retention"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Explorer:NoDataExecutionPrevention" -segment_name "Windows_Reg_Explorer:NoDataExecutionPrevention"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Explorer:NoHeapTerminationOnCorruption" -segment_name "Windows_Reg_Explorer:NoHeapTerminationOnCorruption"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer:PreXPSP2ShellProtocolBehavior" -segment_name "Windows_Reg_Explorer:PreXPSP2ShellProtocolBehavior"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\MicrosoftAccount:DisableUserAuth" -segment_name "Windows_Reg_MicrosoftAccount:DisableUserAuth"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender:PUAProtection" -segment_name "Windows_Reg_Windows Defender:PUAProtection"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender:DisableAntiSpyware" -segment_name "Windows_Reg_Windows Defender:DisableAntiSpyware"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet:LocalSettingOverrideSpynetReporting" -segment_name "Windows_Reg_Spynet:LocalSettingOverrideSpynetReporting"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR:ExploitGuard_ASR_Rules" -segment_name "Windows_Reg_ASR:ExploitGuard_ASR_Rules"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:26190899-1602-49e8-8b27-eb1d0a1ce869" -segment_name "Windows_Reg_Rules:26190899-1602-49e8-8b27-eb1d0a1ce869"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:3b576869-a4ec-4529-8536-b80a7769e899" -segment_name "Windows_Reg_Rules:3b576869-a4ec-4529-8536-b80a7769e899"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:56a863a9-875e-4185-98a7-b882c64b5ce5" -segment_name "Windows_Reg_Rules:56a863a9-875e-4185-98a7-b882c64b5ce5"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:5beb7efe-fd9a-4556-801d-275e5ffc04cc" -segment_name "Windows_Reg_Rules:5beb7efe-fd9a-4556-801d-275e5ffc04cc"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84" -segment_name "Windows_Reg_Rules:75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:7674ba52-37eb-4a4f-a9a1-f0f9a1619a2c" -segment_name "Windows_Reg_Rules:7674ba52-37eb-4a4f-a9a1-f0f9a1619a2c"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:92e97fa1-2edf-4476-bdd6-9dd0b4dddc7b" -segment_name "Windows_Reg_Rules:92e97fa1-2edf-4476-bdd6-9dd0b4dddc7b"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2" -segment_name "Windows_Reg_Rules:9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4" -segment_name "Windows_Reg_Rules:b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:be9ba2d9-53ea-4cdc-84e5-9b1eeee46550" -segment_name "Windows_Reg_Rules:be9ba2d9-53ea-4cdc-84e5-9b1eeee46550"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:d3e037e1-3eb8-44c8-a917-57927947596d" -segment_name "Windows_Reg_Rules:d3e037e1-3eb8-44c8-a917-57927947596d"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:d4f940ab-401b-4efc-aadc-ad5f3c50688a" -segment_name "Windows_Reg_Rules:d4f940ab-401b-4efc-aadc-ad5f3c50688a"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules:e6db77e5-3df2-4cf1-b95a-636979351e5b" -segment_name "Windows_Reg_Rules:e6db77e5-3df2-4cf1-b95a-636979351e5b"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\Network Protection:EnableNetworkProtection" -segment_name "Windows_Reg_NetworkProtection:EnableNetworkProtection"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection:DisableIOAVProtection" -segment_name "Windows_Reg_RTProtection:DisableIOAVProtection"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection:DisableRealtimeMonitoring" -segment_name "Windows_Reg_RTProtection:DisableRealtimeMonitoring"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection:DisableBehaviorMonitoring" -segment_name "Windows_Reg_RTProtection:DisableBehaviorMonitoring"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection:DisableScriptScanning" -segment_name "Windows_Reg_RTProtection:DisableScriptScanning"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Scan:DisableRemovableDriveScanning" -segment_name "Windows_Reg_Scan:DisableRemovableDriveScanning"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Scan:DisableEmailScanning" -segment_name "Windows_Reg_Scan:DisableEmailScanning"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:fDisableCdm" -segment_name "Windows_Reg_Terminal Services:fDisableCdm"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:fPromptForPassword" -segment_name "Windows_Reg_TS:fPromptForPassword"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:fEncryptRPCTraffic" -segment_name "Windows_Reg_TS:fEncryptRPCTraffic"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:SecurityLayer" -segment_name "Windows_Reg_TS:SecurityLayer"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:UserAuthentication" -segment_name "Windows_Reg_TS:UserAuthentication"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:MinEncryptionLevel" -segment_name "Windows_Reg_TS:MinEncryptionLevel"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:DeleteTempDirsOnExit" -segment_name "Windows_Reg_TS:DeleteTempDirsOnExit"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services:PerSessionTempDir" -segment_name "Windows_Reg_TS:PerSessionTempDir"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Internet Explorer\Feeds:DisableEnclosureDownload" -segment_name "Windows_Reg_Feeds:DisableEnclosureDownload"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Windows Search:AllowIndexingEncryptedStoresOrItems" -segment_name "Windows_Reg_WSearch:AllowIndexingEncryptedStoresOrItems"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:EnableSmartScreen" -segment_name "Windows_Reg_System:EnableSmartScreen"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:ShellSmartScreenLevel" -segment_name "Windows_Reg_System:ShellSmartScreenLevel"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer:AlwaysInstallElevated" -segment_name "Windows_Reg_Installer:AlwaysInstallElevated"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU:NoAutoRebootWithLoggedOnUsers" -segment_name "Windows_Reg_AU:NoAutoRebootWithLoggedOnUsers"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU:NoAutoUpdate" -segment_name "Windows_Reg_AU:NoAutoUpdate"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU:ScheduledInstallDay" -segment_name "Windows_Reg_AU:ScheduledInstallDay"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate:ManagePreviewBuildsPolicyValue" -segment_name "Windows_Reg_WindowsUpdate:ManagePreviewBuildsPolicyValue"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate:DeferFeatureUpdates" -segment_name "Windows_Reg_WindowsUpdate:DeferFeatureUpdates"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate:DeferFeatureUpdatesPeriodInDays" -segment_name "Windows_Reg_WindowsUpdate:DeferFeatureUpdatesPeriodInDays"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate:DeferQualityUpdates" -segment_name "Windows_Reg_WindowsUpdate:DeferQualityUpdates"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate:DeferQualityUpdatesPeriodInDays" -segment_name "Windows_Reg_WindowsUpdate:DeferQualityUpdatesPeriodInDays"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppInstaller:EnableAppInstaller" -segment_name "Windows_Reg_AppInstaller:EnableAppInstaller"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppInstaller:EnableExperimentalFeatures" -segment_name "Windows_Reg_AppInstaller:EnableExperimentalFeature"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppInstaller:EnableHashOverride" -segment_name "Windows_Reg_AppInstaller:EnableHashOverride"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\AppInstaller:EnableMSAppInstallerProtocol" -segment_name "Windows_Reg_AppInstaller:EnableMSAppInstallerProtocol"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient:DoHPolicy" -segment_name "Windows_Reg_DNSClient:DoHPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System:AllowCustomSSPsAPs" -segment_name "Windows_Reg_System:AllowCustomSSPsAPs"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System:EnableMPR" -segment_name "Windows_Reg_System:EnableMPR"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SAM:relaxminimumpasswordlengthlimits" -segment_name "Windows_Reg_SAM:relaxminimumpasswordlengthlimits"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa:RunAsPPL" -segment_name "Windows_Reg_Lsa:RunAsPP"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0:AuditReceivingNTLMTraffic" -segment_name "Windows_Reg_MSV1_0:AuditReceivingNTLMTraffic"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters:AuditNTLMInDomain" -segment_name "Windows_Reg_Netlogon:AuditNTLMInDomain"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0:RestrictSendingNTLMTraffic" -segment_name "Windows_Reg_MSV1_0:RestrictSendingNTLMTraffic"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\Wintrust\Config:EnableCertPaddingCheck" -segment_name "Windows_Reg_Config:EnableCertPaddingCheck"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Group Policy\{827D319E-6EAC-11D2-A4EA-00C04F79F83A}:NoBackgroundPolicy" -segment_name "Windows_Reg_Security:NoBackgroundPolicy"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Group Policy\{827D319E-6EAC-11D2-A4EA-00C04F79F83A}:NoGPOListChanges" -segment_name "Windows_Reg_Security:NoGPOListChanges"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\MpEngine:EnableFileHashComputation" -segment_name "Windows_Reg_MpEngine:EnableFileHashComputation"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Scan:DisablePackedExeScanning" -segment_name "Windows_Reg_Scan:DisablePackedExeScanning"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:BackupDirectory" -segment_name "Windows_Reg_LAPS:BackupDirectory"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:PwdExpirationProtectionEnabled" -segment_name "Windows_Reg_LAPS:PwdExpirationProtectionEnabled"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:ADPasswordEncryptionEnabled" -segment_name "Windows_Reg_LAPS:ADPasswordEncryptionEnabled"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:PasswordComplexity" -segment_name "Windows_Reg_LAPS:PasswordComplexity"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:PasswordLength" -segment_name "Windows_Reg_LAPS:PasswordLength"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:PasswordAgeDays" -segment_name "Windows_Reg_LAPS:PasswordAgeDays"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:PostAuthenticationResetDelay" -segment_name "Windows_Reg_LAPS:PostAuthenticationResetDelay"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\LAPS:PostAuthenticationActions" -segment_name "Windows_Reg_LAPS:PostAuthenticationActions"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\W32Time\TimeProviders\NtpClient:Enabled" -segment_name "Windows_Reg_NtpClient:Enabled"
get-segment_regkey -regkey "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\W32Time\TimeProviders\NtpServer:Enabled" -segment_name "Windows_Reg_NtpServer:Enabled"


<#
{% endif %}
#>


<#
{% if ('user_registry' in check_list  or 'all' in check_list) and '-user_registry' not in check_list %}
# Windows User Registry keys
#>

$crt++
Write-Output "$crt. $computer - Extracting User registry keys"
msgprint "info" "info $crt. $computer - Extracting User registry keys"

get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Policies\Microsoft\Windows\Control Panel\Desktop:ScreenSaveActive" -segment_name "Windows_Reg_Users_Desktop:ScreenSaveActive"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Policies\Microsoft\Windows\Control Panel\Desktop:ScreenSaverIsSecure" -segment_name "Windows_Reg_Users_Desktop:ScreenSaverIsSecure"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Policies\Microsoft\Windows\Control Panel\Desktop:ScreenSaveTimeOut" -segment_name "Windows_Reg_Users_Desktop:ScreenSaveTimeOut"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Policies\Microsoft\Windows\CurrentVersion\PushNotifications:NoToastApplicationNotificationOnLockScreen" -segment_name "Windows_Reg_Users_PushNotifications:NoToastApplicationNotificationOnLockScreen"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments:ScanWithAntiVirus" -segment_name "Windows_Reg_Users_Attachments:ScanWithAntiVirus"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments:SaveZoneInformation" -segment_name "Windows_Reg_Users_Attachments:SaveZoneInformation"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Policies\Microsoft\Windows\CloudContent:ConfigureWindowsSpotlight" -segment_name "Windows_Reg_Users_CloudContent:ConfigureWindowsSpotlight"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Policies\Microsoft\Windows\CloudContent:DisableThirdPartySuggestions" -segment_name "Windows_Reg_Users_CloudContent:DisableThirdPartySuggestions"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\SOFTWARE\Policies\Microsoft\Windows\CloudContent:DisableSpotlightCollectionOnDesktop" -segment_name "Windows_Reg_Users_CloudContent:DisableSpotlightCollectionOnDesktop"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer:NoInplaceSharing" -segment_name "Windows_Reg_Users_Explorer:NoInplaceSharing"
get-segment_usersregkey -regkey "HKEY_USERS\[USER SID]\Software\Policies\Microsoft\Windows\Installer:AlwaysInstallElevated" -segment_name "Windows_Reg_Users_Installer:AlwaysInstallElevated"

<#
{% endif %}
#>

$crt++
Write-Output "$crt. $computer - Impersonate a client after authentication [MS]"
msgprint "info" "info $crt. $computer - Impersonate a client after authentication [MS]"
$file_stream_output.WriteLine("#### <Windows_impersonate>")

try {
    $IISInstalled = (Get-WindowsFeature Web-Server).Installed
    $computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem
    $DomainName = $computerSystem.Domain
    $DomainRole = ("Standalone Workstation","Member Workstation","Standalone Server","Member Server","Backup Domain Controller","Primary Domain Controller")
    $serverRoleString = $DomainRole[$computerSystem.DomainRole]
    $pass = "Fail"

    # Empty out if we can't find SecEdit.exe
    $SecEdit = Join-Path ([Environment]::GetFolderPath([Environment+SpecialFolder]::System)) "SecEdit.exe"
    if (Test-Path $SecEdit) {
        $seceditFile = [System.IO.Path]::GetTempFileName()
        $rtncode = secedit /export /cfg $seceditFile /quiet

        if (Test-Path $seceditFile) {
            $seceditdata = get-content $seceditFile | where { $_ -like "SeImpersonatePrivilege*" }
            Remove-Item $seceditFile -Force -Confirm:$false
        }

    }
    If (($serverRoleString -eq "Member Server" ) -and $IISInstalled -and $seceditdata -eq "SeImpersonatePrivilege = *S-1-5-19,*S-1-5-20,*S-1-5-32-544,*S-1-5-32-568,*S-1-5-6") {
        $pass = "Pass"
        }
    else {
       If ((-not $IISInstalled) -and $seceditdata -eq "SeImpersonatePrivilege = *S-1-5-19,*S-1-5-20,*S-1-5-32-544,*S-1-5-6") {
        $pass = "Pass"
        }
       else {
        $pass = "Fail"
    }
    }
    $out = @()
    $out += [pscustomobject]@{
            "MachineName" = $computer
            "ServerRole" = $serverRoleString
            "IISInstalled" = $IISInstalled
            "SeImpersonatePrivilege" = $seceditdata
            "Pass" = $pass
        }
    $Out | ConvertTo-Csv -delimiter ";" -NoTypeInformation | foreach-object {$file_stream_output.WriteLine($_)}
}
catch {
        $file_stream_output.WriteLine("Error: $_")
}
$file_stream_output.WriteLine("#### </Windows_impersonate>")


# ----------------------------------------END code for TECHNICAL SPECIFICATIONS ------------------------------------------------------------------------------------

# Important to close the stream before using custom code
$Global:file_stream_output.Close()

# BEGIN ANSIBLE MANAGED BLOCK
# END ANSIBLE MANAGED BLOCK

# 99. Compress the logs (Compress-Archive requires PowerShell 5+) if ZipLog is True
# Convert to UTF8

(Get-Content $LogPath) | Out-File $LogPath -encoding UTF8
(Get-Content $LogPath) -replace "`0", "" | Set-Content $LogPath
(Get-Content $LogPath) | where-object {$_ -ne ""} | Set-Content $LogPath
if ($ZipLog -eq $True) {
    $TimeStamp = Get-Date -Format yyyyMMdd-HHmmss
    Copy-Item -Path $LogPath -Destination $logdir
    Copy-Item -Path $LogF -Destination $logdir
    if (($PSVersionTable.PSVersion).Major -lt 5){
        MsgPrint "Info" "Powershell version too old for creating zip"
        Write-Output "Please zip folder ""$logdir"" and collect for further analysis."
    }
    else{
        Write-Output "Compressing Reports..."
        MsgPrint "Info" "Compressing reports and clean working folder/files"
        Compress-Archive -Path $logdir* -CompressionLevel Optimal -DestinationPath $localfolder\$computer-$TimeStamp-report.zip
        Remove-Item -path $logdir -recurse
        Write-Output "Please collect $localfolder\$computer-$TimeStamp-report.zip for further analysis."
        Write-Output "======================================================================================"
    }
}
Else {
    MsgPrint "Info" "Cleaning working folder/files"
    Remove-Item -path $logdir -recurse
}
Write-Output " "
Write-Output "Script completed for $computer."
MsgPrint "OK" "Data collection status: OK"

##########################################################################
